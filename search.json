[{"title":"认识一下，我叫“曦曦”","url":"/2021/06/06/1.hello-world/","content":"hey 你好，很高兴认识你 ，我叫曦曦    在后面的交流中，我很希望我们能相互交流，学到更多的东西！！！    cheers！！！\n\n","categories":["认识"],"tags":["Hello"]},{"title":"简单搭建自己的云平台","url":"/2022/05/15/12.cloud_stage/","content":"前言我这里是Windows10&#x2F;11专业工作版(其他Windows版本也适用)如果你的设备是已经是结束支持的Windows7，请查阅其他相关是手册什么是云平台简单概念云平台是基于云计算技术，为用户提供计算、存储、网络等一系列信息技术资源和服务的平台\n核心组成部分基础设施即服务（IaaS）：提供基础的计算、存储和网络资源，用户可按需租用服务器、存储空间、网络带宽等，如阿里云的弹性计算服务。平台即服务（PaaS）：在IaaS基础上，提供软件开发、运行和管理的平台，用户只需专注于开发应用，无需管理底层基础设施，如谷歌的App Engine。软件即服务（SaaS）：直接向用户提供各种软件应用服务，用户通过互联网浏览器使用软件，如腾讯文档等。\n特点灵活性与可扩展性：用户能根据业务需求灵活调整资源，实现快速扩展或收缩。高可靠性：云平台通常有多个数据中心和冗余备份，保障服务的连续性和数据的安全性。成本效益：用户按需付费，无需大量前期硬件投资，降低了企业的运营成本。便捷的管理：用户可通过云平台的管理界面轻松管理和监控资源，无需专业的运维团队。\n应用场景企业信息化：企业可将业务系统部署在云平台，实现办公自动化、客户关系管理等功能。大数据与人工智能：云平台提供强大的计算和存储能力，支持大数据分析和人工智能模型训练。网站与应用托管：开发者可将网站和应用程序部署在云平台，快速上线并实现全球访问简单搭建一个云计算平台本次是以搭建一个先电云平台为例\n准备阶段软件：VMware Workstation Pro 17镜像：CentOS-7-x86_64-DVD-1511.isoXianDian-IaaS-v2.2.iso\n硬件配置打开VMware Workstation Pro 17，建立两个虚拟机，一个命名为controller 另一个命名为 compute硬件配置如下内存    3G处理器    2G硬盘    50GCD&#x2F;DVD    CentOS-7-x86_64-DVD-1511.iso网络适配器    VMnet1网络适配器2  VMnet2\n网络配置主机名\t       VMnet1            VMnet2controller\t  192.168.28.10   \t192.168.128.10compute\t      192.168.28.20\t    192.168.128.20\n搭建过程改主机名字，关防火墙，设置主机映射开启虚拟机controller\nhostnamectl set-hostname controllersystemctl stop firewalldsystemctl disable firewalldsetenforce 0sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/configcat &gt;&gt;/etc/hosts&lt;&lt;eof192.168.28.10 controller192.168.28.20 computeeof\ncompute\nhostnamectl set-hostname computesystemctl stop firewalldsystemctl disable firewalldsetenforce 0sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/configcat &gt;&gt;/etc/hosts&lt;&lt;eof192.168.28.10 controller192.168.28.20 computeeof\ncontroller 传输并挂载镜像建立镜像存放的目录进入opt目录，创建挂载点 centos 以及 iaas，（没有opt要自己建立),使用CRT将xiandian镜像传入opt目录下\ncd /optmkdir centos iaas\n镜像自己挂载设置开机自动挂载镜像文件\ncat &gt;&gt;/etc/fstab&lt;&lt;eof\n挂载立即生效\nmount -a    \n修改yum源进入 &#x2F;etc&#x2F;yum.repos.d 目录，删除或移动里面的大写C开头的文件，否则后面会造成缓存错误，载创建repo源文件\ncd /etc/yum.repos.dmkdir bkmv C* bkcat &gt;&gt;/etc/yum.repos.d/local.repo&lt;&lt;eof[centos]name=centosbaseurl=file:///opt/centosgpgcheck=0enabled=1[iaas]name=iaasbaseurl=file:///opt/iaas/iaas-repogpgcheck=0enabled=1eof\n清除缓存，生成缓存yum clean allyum makecache\n出现提示，说明是成功了（不需要和我的完全一摸一样，因为iso版本的不同，生成的缓存也不同）\n[root@controller ~]# yum makecache已加载插件：fastestmirrorcentos                                                                                                                                  | 3.6 kB  00:00:00     iaas                                                                                                                                    | 2.9 kB  00:00:00     (1/7): centos/filelists_db                                                                                                              | 2.9 MB  00:00:00     (2/7): centos/group_gz                                                                                                                  | 155 kB  00:00:00     (3/7): iaas/filelists_db                                                                                                                | 1.9 MB  00:00:00     (4/7): iaas/primary_db                                                                                                                  | 2.3 MB  00:00:00     (5/7): centos/primary_db                                                                                                                | 2.8 MB  00:00:00     (6/7): iaas/other_db                                                                                                                    | 692 kB  00:00:00     (7/7): centos/other_db                                                                                                                  | 1.2 MB  00:00:00     Determining fastest mirrors元数据缓存已建立\n注意，出现下面的错误，可能是之前的步骤出错了，可能是yum源没配置好，也可能是没挂载好！！！\n[root@compute yum.repos.d]# yum makecache已加载插件：fastestmirror One of the configured repositories failed (未知), and yum doesn&#x27;t have enough cached data to continue. At this point the only safe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this:     1. Contact the upstream for the repository and get them to fix the problem.     2. Reconfigure the baseurl/etc. for the repository, to point to a working        upstream. This is most often useful if you are using a newer        distribution release than is supported by the repository (and the        packages for the previous distribution release still work).     3. Disable the repository, so yum won&#x27;t use it by default. Yum will then        just ignore the repository until you permanently enable it again or use        --enablerepo for temporary usage:             yum-config-manager --disable &lt;repoid&gt;      4. Configure the failing repository to be skipped, if it is unavailable.        Note that yum will try to contact the repo. when it runs most commands,        so will have to try and fail each time (and thus. yum will be be much        slower). If it is a very temporary problem though, this is often a nice        compromise:             yum-config-manager --save --setopt=&lt;repoid&gt;.skip_if_unavailable=true Cannot find a valid baseurl for repo: centos\n如果是出现了 &#x2F;var&#x2F;run&#x2F;yum.pid 的消息\nrm -rf /var/run/yum.pid\n接下来安装vsftpd和iaas-xiandianyum install iaas-xiandian vsftpd -y\n增加匿名访问在controller上安装 ftp（文件传输）服务\ncat &gt;&gt;/etc/vsftpd/vsftpd.conf&lt;&lt;eofanon_root=/opteofsystemctl restart networksystemctl start vsftpdsystemctl enable vsftpd\n先电镜像配置接下来配置xiandian的openrc.sh应答文件（一个字都不能错）\nsed -i &#x27;s/.//&#x27; /etc/xiandian/openrc.shsed -i &#x27;s/PASS=/PASS=000000/g&#x27; /etc/xiandian/openrc.shsed -i &#x27;s/HOST_IP=/HOST_IP=192.168.28.10/g&#x27; /etc/xiandian/openrc.shsed -i &#x27;s/HOST_NAME=/HOST_NAME=controller/g&#x27; /etc/xiandian/openrc.shsed -i &#x27;s/HOST_IP_NODE=/HOST_IP_NODE=192.168.28.20/g&#x27; /etc/xiandian/openrc.shsed -i &#x27;s/HOST_NAME_NODE=/HOST_NAME_NODE=compute/g&#x27; /etc/xiandian/openrc.shsed -i &#x27;s/RABBIT_USER=/RABBIT_USER=openstack/g&#x27; /etc/xiandian/openrc.shsed -i &#x27;s/DOMAIN_NAME=/DOMAIN_NAME=demo/g&#x27; /etc/xiandian/openrc.shsed -i &#x27;s/METADATA_SECRET=/METADATA_SECRET=000000/g&#x27; /etc/xiandian/openrc.shsed -i &#x27;s/INTERFACE_NAME=/INTERFACE_NAME=ens34/g&#x27; /etc/xiandian/openrc.sh\n接着使用命令   cat &#x2F;etc&#x2F;xiandian&#x2F;openrc.sh   查看配置文件，配置完后，应如下\n#--------------------system Config--------------------###Controller Server Manager IP. example:x.x.x.xHOST_IP=192.168.28.10 #Controller Server hostname. example:controllerHOST_NAME=controller #Compute Node Manager IP. example:x.x.x.xHOST_IP_NODE=192.168.28.20 #Compute Node hostname. example:computeHOST_NAME_NODE=compute #--------------------Rabbit Config ------------------###user for rabbit. example:openstackRABBIT_USER=openstack #Password for rabbit user .example:000000RABBIT_PASS=000000 #--------------------MySQL Config---------------------###Password for MySQL root user . exmaple:000000DB_PASS=000000 #--------------------Keystone Config------------------###Password for Keystore admin user. exmaple:000000DOMAIN_NAME=demoADMIN_PASS=000000DEMO_PASS=000000 #Password for Mysql keystore user. exmaple:000000KEYSTONE_DBPASS=000000 #--------------------Glance Config--------------------###Password for Mysql glance user. exmaple:000000GLANCE_DBPASS=000000 #Password for Keystore glance user. exmaple:000000GLANCE_PASS=000000 #--------------------Nova Config----------------------###Password for Mysql nova user. exmaple:000000NOVA_DBPASS=000000 #Password for Keystore nova user. exmaple:000000NOVA_PASS=000000 #--------------------Neturon Config-------------------###Password for Mysql neutron user. exmaple:000000NEUTRON_DBPASS=000000 #Password for Keystore neutron user. exmaple:000000NEUTRON_PASS=000000 #metadata secret for neutron. exmaple:000000METADATA_SECRET=000000 #External Network Interface. example:eth1INTERFACE_NAME=ens37 #First Vlan ID in VLAN RANGE for VLAN Network. exmaple:101minvlan= #Last Vlan ID in VLAN RANGE for VLAN Network. example:200maxvlan= #--------------------Cinder Config--------------------###Password for Mysql cinder user. exmaple:000000CINDER_DBPASS= #Password for Keystore cinder user. exmaple:000000CINDER_PASS= #Cinder Block Disk. example:md126p3BLOCK_DISK= #--------------------Trove Config--------------------###Password for Mysql Trove User. exmaple:000000TROVE_DBPASS= #Password for Keystore Trove User. exmaple:000000TROVE_PASS= #--------------------Swift Config---------------------###Password for Keystore swift user. exmaple:000000SWIFT_PASS= #The NODE Object Disk for Swift. example:md126p4.OBJECT_DISK= #The NODE IP for Swift Storage Network. example:x.x.x.x.STORAGE_LOCAL_NET_IP= #--------------------Heat Config----------------------###Password for Mysql heat user. exmaple:000000HEAT_DBPASS= #Password for Keystore heat user. exmaple:000000HEAT_PASS= #--------------------Ceilometer Config----------------###Password for Mysql ceilometer user. exmaple:000000CEILOMETER_DBPASS= #Password for Keystore ceilometer user. exmaple:000000CEILOMETER_PASS= #--------------------AODH Config----------------###Password for Mysql AODH user. exmaple:000000AODH_DBPASS= #Password for Keystore AODH user. exmaple:000000AODH_PASS=\n现在controller的配置就结束了！！！\ncompute 配置检查是否连接上controller的挂载的文件[root@compute yum.repos.d]# curl ftp://192.168.28.10-rw-r--r--    1 0        0        2851502080 Jun 04  2020 XianDian-IaaS-v2.2.isodr-xr-xr-x    8 0        0            2048 Dec 09  2015 centosdrwxr-xr-x    4 0        0            2048 Nov 06  2017 iaas\n创建repo源进入opt目录，创建centos和iaas文件，移动或删除大写C开头文件，创建一个ftp.repo源文件\ncd /optmkdir centos iaascd /etc/yum.repos.d/mkdir bkmv C* bktouch ftp.repo\n\n修改 repo源进入 &#x2F;etc&#x2F;yum.repos.d&#x2F;ftp.repo 写入\ncat &gt;&gt;/etc/yum.repos.d/ftp.repo&lt;&lt;eof[centos]name=centosbaseurl=ftp://192.168.28.10/centosgpgcheck=0enabled=1[iaas]name=iaasbaseurl=ftp://192.168.28.10/iaas/iaas-repogpgcheck=0enabled=1eof\n清除缓存，生成缓存yum clean allyum makecache\n\n如出现以下画面，说明成功[root@compute yum.repos.d]# yum makecache已加载插件：fastestmirrorcentos                                                                                                                                  | 3.6 kB  00:00:00     iaas                                                                                                                                    | 2.9 kB  00:00:00     (1/7): centos/group_gz                                                                                                                  | 155 kB  00:00:00     (2/7): centos/filelists_db                                                                                                              | 2.9 MB  00:00:00     (3/7): centos/primary_db                                                                                                                | 2.8 MB  00:00:00     (4/7): centos/other_db                                                                                                                  | 1.2 MB  00:00:00     (5/7): iaas/filelists_db                                                                                                                | 1.9 MB  00:00:00     (6/7): iaas/primary_db                                                                                                                  | 2.3 MB  00:00:00     (7/7): iaas/other_db                                                                                                                    | 692 kB  00:00:00     Determining fastest mirrors元数据缓存已建立\n下载 iaas-xiandain 进入 &#x2F;etc&#x2F;xiandian ，将openrc.sh 改名为openrc.sh.bk 备份 以防出现错误\n再将 controller(192.168.28.10)中的 &#x2F;etc&#x2F;xiandian&#x2F;openrc.sh 文件传输到 本机\nyum -y install iaas-xiandiancd /etc/xiandianmv openrc.sh openrc.sh.bkscp 192.168.28.10:/etc/xiandian/openrc.sh openrc.sh\n执行安装脚本两个节点均执行初始化脚本\niaas-pre-host.sh\n注意：执行需要一段时间，不要去按回车什么的了，在出现  【reboot】提示后，必须重启，否则之后的实例发不出去，问题很大！！！\n控制节点安装 （controller）cd /usr/local/bincat &gt;&gt;/usr/local/bin/all-in-one.sh&lt;&lt;eofiaas-install-mysql.sh iaas-install-keystone.sh iaas-install-glance.sh iaas-install-nova-controller.shiaas-install-neutron-controller.shiaas-install-neutron-controller-gre.shiaas-install-dashboard.sheofsource all-in-one.sh\n计算节点安装（compute）cd /usr/local/bincat &gt;&gt;/usr/local/bin/all-in-one.sh&lt;&lt;eofiaas-install-nova-compute.shiaas-install-neutron-compute.shiaas-install-neutron-compute-gre.sheofsource all-in-one.sh\n安装需要很长时间，请耐心等待执行完成后，使用浏览器访问http:&#x2F;&#x2F;控制IP&#x2F;dashboard\n访问访问成功界面域：demo用户名：admin密码：000000总结1、建立两个虚拟机，分别命名为controller和compute，并配置好网卡和硬件2、controller负责挂载两个镜像、配置yum源、先电镜像配置3、compute 负责repo源4、两个节点都安装先电的服务5、使用实体机浏览器访问","categories":["Sever"],"tags":["Cloud"]},{"title":"一周年 - 特别篇","url":"/2022/06/06/13.years1/","content":"【我的小窝也一岁了】从2021年6月搭起第一个Hexo框架至今，这个用Markdown垒成的小窝，竟已在网络荒原上生长出了属于自己的根系。还记得初遇Hexo时，被它“快速、简洁、极客”的气质吸引——没有复杂的后台，只需专注文字与代码，像在数字世界里辟出一块“手写日记”的自留地，而这一种，就是365天。\n最初的日子，全靠翻官方文档和GitHubIssue磕磕绊绊：跟着教程敲 hexo new post ，为了换主题在仓库里找了整夜适配的CSS，甚至因误删 _config.yml 文件导致博客“裸奔”——但每次崩溃后重新调试的过程，都像给小站打了一针“成长补丁”。\n选择Hexo，本就是偏爱它“让内容回归本质”的克制。没有花哨的富文本编辑器，只有纯文本与Markdown语法的对话——这种“简陋”反而让我更专注于表达：\n此刻：写给下一个365天的“待办清单”\n如今的小站，依然有未填的坑.但比起“完善”，我更珍惜它现在的“不完美”——那些没解决的BUG、没写完的教程、没实现的创意，都是未来继续折腾的理由。\nHexo教会我的，从来不止是搭博客。它让我明白：在这个追求“快速迭代”的时代，慢下来用代码和文字认真记录，本身就是一种浪漫。下一年，愿继续在Markdown的格子里种故事，在Hexo的框架里藏星光——让这个小站，永远是那个“不追流量、只追热爱”的数字角落。\n一周年快乐，我的Hexo小窝。下一次敲 hexo deploy 时，希望我们都变成了更喜欢的样子\n","categories":["特别篇"],"tags":["Anniversary"]},{"title":"使用Linux搭建http服务器，实现你的博主梦","url":"/2022/03/13/10.httpd/","content":"前言这里只是简单介绍与搭建http服务器！！！\n\n什么是http服务器HTTP服务器，也称为Web服务器，是一种计算机程序，它驻留在因特网上，主要功能是接收并处理来自Web浏览器等客户端的请求，并返回相应的响应。此外，HTTP服务器还可以用于存储和提供网站文件，以便全球用户可以浏览；同时，也可以存储和提供数据文件，供全球用户下载。如何搭建http服务器前期准备确认centOS版本登录到 CentOS 7 系统，打开终端，输入下面的命令，看到 “CentOS Linux release 7.x” 即表示版本正确。\ncat /etc/redhat-release\n更新系统组件在终端执行下面的命令，更新系统软件包，避免后续安装出现软件冲突问题。\nsudo yum update -y &amp;&amp; sudo yum upgrade -y\n\nApache HTTP 服务什么是Apache常简称为 Apache，是 Apache 软件基金会开发和维护的一款开源的 HTTP 服务器软件。作为互联网基础设施中关键的一部分，它能处理客户端（如网页浏览器）发送的 HTTP 请求，并将对应的网页或数据传回客户端。比如当在浏览器中输入网址，背后就可能是 Apache 服务器在传送所请求的网页。\n安装Apache服务在终端输入下面命令，yum 是 CentOS 的软件包管理器，它会自动解决依赖关系并完成安装。\nsudo yum install httpd -y\n配置 Apache 服务Apache 的主配置文件路径为&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf，可以使用 vim 编辑器进行修改\nsudo vim /etc/httpd/conf/httpd.conf\n常见的配置项说明：Listen：指定服务器监听的端口，默认为Listen 80 。ServerName：设置服务器的域名，如果没有域名，可以写服务器的 IP 地址，如ServerName your_domain:80（将your_domain替换为实际 IP 或域名）。DirectoryIndex：定义默认首页文件，默认是DirectoryIndex index.html 。修改完成后，按ESC键，然后输入:wq保存并退出 vim 编辑器。\n启动 Apache 服务启动服务：在终端执行命令sudo systemctl start httpd ，启动 Apache 服务。设置开机自启：执行命令sudo systemctl enable httpd ，这样服务器重启后，Apache 服务会自动启动。检查运行状态：使用命令&#96;&#96;systemctl status httpd&#96;&#96;&#96; ，如果看到 “active (running)” 标识，则表示 httpd 运行成功。配置防火墙CentOS 7 默认使用firewalld作为防火墙，需要放行 HTTP 和 HTTPS 服务：1、添加服务规则：执行以下命令：\nsudo firewall-cmd --permanent --add-service=httpsudo firewall-cmd --permanent --add-service=https\n2、重新加载防火墙配置：执行sudo firewall-cmd –reload ，使新规则生效。3、验证防火墙规则：使用命令firewall-cmd –list-all ，查看已配置的规则。测试页面访问1、命令行测试：在终端输入curl 127.0.0.1 ，如果能看到网页的内容，则表示服务器基本正常。2、浏览器访问：在浏览器地址栏中输入服务器的 IP 地址（如果配置了域名，也可以输入域名），如果看到默认的测试页面（如 “Testing 123…” 或其他默认内容），则说明 HTTP 服务器搭建成功。结语1、检查系统版本2、下载apache服务3、配置apache服务4、配置防火墙5、检查配置是否成功","categories":["Sever"],"tags":["Cloud"]},{"title":"水仙写法","url":"/2022/06/20/13.%E6%B0%B4%E4%BB%99%E5%86%99%E6%B3%95/","content":"前言我这里是Windows10&#x2F;11专业工作版(其他Windows版本也适用)如果你的设备是已经是结束支持的Windows7，请查阅其他相关是手册这里演示的代码为c++代码   水仙花数概念水仙花数是指一个3位正整数，其每个位上的数字的3次幂之和等于它本身\n问题1-判断是否是水仙花数分析：满足条件每个位上的数字的3次幂之和等于它本身就是1、输入你要判断的数字2、求出每个位上的数字3、判断代码如下：\n#include&lt;iostream&gt;#include&lt;cmath&gt;int main(void)&#123;    int i ;    std::cin&gt;&gt;i; // 输入一个三位数        int a = i%10; //求个位        int b = i/10%10; // 求十位        int c = i /100;  // 求百位        if (pow(a,3)+pow(b,3)+pow(c,3) == i ) // 用概念判断一下是否是三位数            std::cout&lt;&lt;&quot;yes&quot;;   // 是就输出yes        else            std::cout&lt;&lt;&quot;no&quot;; // 不是就输出 no            return 0; &#125;\n问题2-全部的水仙数分析，在上面的基础山添加了一个信息是：全部即是要遍历一下全部的三位数，代码就变成了下面的结果了\n#include&lt;iostream&gt;#include&lt;cmath&gt;int main(void)&#123;    for(int i =100;i&lt;=999;i++)&#123;        int a = i%10; //求个位        int b = i/10%10; // 求十位        int c = i /100;  // 求百位        if (pow(a,3)+pow(b,3)+pow(c,3) == i ) // 用概念判断一下是否是水仙花数            std::cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;    return 0; &#125;\n\n提升 - 水仙写法判断是否是水仙花数这里我们已经知道了位数是三位数，所以，我们就知道了位数是3，那么现在我们就是用水仙写法来解决问题吧！思路分析：我们可以将这个数的位数看作循环的次数，那么就知道的循环变量变化的等式是一个整除10的自运算，然后在每次都涉及到了对数字的每一个位上的数进行3次幂操作，每个位上的数就是这个数和10取余数的结果，再将取好了的余数进行3次幂操作，最后是用累加起来就达到想要的效果了,我们就得到了下面的代码\n#include&lt;iostream&gt;#include&lt;cmath&gt;int main(void)&#123;        int i ;        std::cin&gt;&gt;i;        int temp  = i,sum = 0;        while(temp)&#123;            sum+=pow(temp%10,3);  // 计算每个位的三次的和            temp /= 10; // 去掉已经计算的位            &#125;        if(sum == i)  // 用概念判断一下是否是水仙花数               std::cout&lt;&lt;&quot;yes&quot;;   // 是就输出yes        else            std::cout&lt;&lt;&quot;no&quot;; // 不是就输出 no    return 0; &#125;\n全部的水仙花数全部的水仙花数就可以写成下面的效果\n#include&lt;iostream&gt;#include&lt;cmath&gt;int main(void)&#123;        for(int i =100;i&lt;=999;i++)&#123;            int temp  = i,sum = 0;            while(temp)&#123;                sum+=pow(temp%10,3); // 计算每个位的三次的和                temp /= 10; // 去掉已经计算的位            &#125;            if(sum == i)  // 用概念判断一下是否是水仙花数                std::cout&lt;&lt;i&lt;&lt;&quot; &quot;;        &#125;    return 0; &#125;\n\n拓展计算数字的位数得到了这思路我们就可以计算一个数字有多位，及是1个数字有多少个数字组成\n#include&lt;iostream&gt;int main(void)&#123;        int i ;        std::cin&gt;&gt;i;        int count= 0;        while( i )&#123;           count++;           i/=10;            &#125;            std::cout&lt;&lt;count;    return 0; &#125;\n判断一个数字是否是回文数设n是一任意自然数。若将n的各位数字反向排列所得自然数n1与n相等，则称n为一回文数。例如，若n&#x3D;1234321，则称n为一回文数；但若n&#x3D;1234567，则n不是回文数。分析：1、求出每个位数的数字2、累和变量自乘103、累和变量加上美每一位上的数字4、求出的和与原来的数字比较\n#include&lt;iostream&gt;int main(void)&#123;        int i ;        std::cin&gt;&gt;i;        int temp = i,sum = 0;        while( temp)&#123;            sum*=10; //扩大1位            sum += temp%10;            temp/=10;            &#125;        if(sum == i ) // 用概念判断一下是否是回文数               std::cout&lt;&lt;&quot;yes&quot;;   // 是就输出yes        else            std::cout&lt;&lt;&quot;no&quot;; // 不是就输出 no        return 0; &#125;\nN位水仙花数概念：指一个n位数，其各位数字的n次方之和确好等于该数本身分析：1、求这个数的位数2、使用判断是否是水仙花数代码就好了\n#include&lt;iostream&gt;#include&lt;cmath&gt;int main(void)&#123;        int i ;        std::cin&gt;&gt;i;        int temp  = i,sum = 0,count=0;    // 求位         while( temp )&#123;           count++;           temp/=10;            &#125;        temp =i;    // 判断水仙花数        while(temp)&#123;            sum+=pow(temp%10,count);  // 计算每个位的位数次的和            temp /= 10; // 去掉已经计算的位            &#125;        if(sum == i)  // 用概念判断一下是否是水仙花数               std::cout&lt;&lt;&quot;yes&quot;;   // 是就输出yes        else            std::cout&lt;&lt;&quot;no&quot;; // 不是就输出 no    return 0; &#125;\n\n总结1、介绍水仙花数的概念2、水仙花数在两大基本问题3、水仙写法解决两大基本问题4、水仙写法的拓展运用","categories":["算法"],"tags":["算法","水仙花数","Coding"]},{"title":"简单使用docker，使你的vps更加高效","url":"/2022/04/15/11.docker/","content":"前言我这里是使用的是CentOS 7 ,由于linux发行版本问题，可能有出入，请多包涵\n\n什么是dockerDocker 是一种用于开发、部署和运行应用程序的开源平台，它利用容器化技术来实现应用程序的打包和隔离\n\n容器化技术容器化是一种轻量级的虚拟化技术，它允许你将应用程序及其依赖项打包到一个独立的容器中。每个容器就像一个小型的、自给自足的虚拟机，包含了运行应用程序所需的一切，如代码、运行时环境、系统工具和库等。\nDocker 的优势环境一致性：Docker 可以确保应用程序在开发、测试和生产环境中的一致性。开发人员可以在本地创建一个与生产环境相同的 Docker 容器，这样就可以避免因环境差异导致的问题。资源利用率高：相较于传统虚拟机，Docker 容器不需要额外的操作系统，它直接运行在宿主机的内核上，因此占用的资源更少，启动速度更快。便于部署和扩展：Docker 容器可以快速部署到任何支持 Docker 的环境中，无论是物理服务器、虚拟机还是云平台。同时，通过 Docker 的集群管理工具，可以轻松实现应用程序的扩展和负载均衡。隔离性：每个 Docker 容器都是相互隔离的，一个容器的故障不会影响其他容器的运行，提高了应用程序的稳定性和安全性。\nDocker 的核心组件镜像（Image）：是一个只读的模板，包含了创建 Docker 容器所需的所有文件和配置信息。可以把镜像看作是应用程序的快照，它可以用来创建多个相同的容器。容器（Container）：是镜像的运行实例。当你启动一个镜像时，就会创建一个容器。容器可以被启动、停止、删除等操作。仓库（Registry）：是用来存储和分发 Docker 镜像的地方。你可以将自己创建的镜像上传到仓库中，也可以从仓库中下载别人共享的镜像。常见的公共仓库有 Docker Hub。\nDocker 的使用场景微服务架构：Docker 可以将每个微服务打包成一个独立的容器，方便进行部署、管理和扩展。持续集成和持续部署（CI&#x2F;CD）：在 CI&#x2F;CD 流程中，使用 Docker 可以确保应用程序在不同环境中的一致性，提高部署效率。开发环境管理：开发人员可以使用 Docker 快速搭建和配置开发环境，避免因环境配置问题导致的开发效率低下。为什么要使用docker容器化技术容器化是一种轻量级的虚拟化技术，它允许你将应用程序及其依赖项打包到一个独立的容器中。每个容器就像一个小型的、自给自足的虚拟机，包含了运行应用程序所需的一切，如代码、运行时环境、系统工具和库等。Docker 的优势环境一致性：Docker 可以确保应用程序在开发、测试和生产环境中的一致性。开发人员可以在本地创建一个与生产环境相同的 Docker 容器，这样就可以避免因环境差异导致的问题。资源利用率高：相较于传统虚拟机，Docker 容器不需要额外的操作系统，它直接运行在宿主机的内核上，因此占用的资源更少，启动速度更快。便于部署和扩展：Docker 容器可以快速部署到任何支持 Docker 的环境中，无论是物理服务器、虚拟机还是云平台。同时，通过 Docker 的集群管理工具，可以轻松实现应用程序的扩展和负载均衡。隔离性：每个 Docker 容器都是相互隔离的，一个容器的故障不会影响其他容器的运行，提高了应用程序的稳定性和安全性。Docker 的核心组件镜像（Image）：是一个只读的模板，包含了创建 Docker 容器所需的所有文件和配置信息。可以把镜像看作是应用程序的快照，它可以用来创建多个相同的容器。容器（Container）：是镜像的运行实例。当你启动一个镜像时，就会创建一个容器。容器可以被启动、停止、删除等操作。仓库（Registry）：是用来存储和分发 Docker 镜像的地方。你可以将自己创建的镜像上传到仓库中，也可以从仓库中下载别人共享的镜像。常见的公共仓库有 Docker Hub。Docker 的使用场景微服务架构：Docker 可以将每个微服务打包成一个独立的容器，方便进行部署、管理和扩展。持续集成和持续部署（CI&#x2F;CD）：在 CI&#x2F;CD 流程中，使用 Docker 可以确保应用程序在不同环境中的一致性，提高部署效率。开发环境管理：开发人员可以使用 Docker 快速搭建和配置开发环境，避免因环境配置问题导致的开发效率低下。为什么要使用docker环境一致性在软件开发过程中，常常会遇到 “在我机器上能运行” 的问题，这是因为不同环境（开发、测试、生产）的配置和依赖可能不同。而 Docker 能将应用及其依赖打包成镜像，在不同环境中创建相同的容器来运行应用，确保应用在各环境的表现一致。比如，一个基于 Python Flask 框架的 Web 应用，开发时使用的是 Python 3.8 以及特定版本的 Flask 库，通过 Docker 可以把这些环境和依赖打包，在测试和生产环境中创建完全相同的运行环境。\n资源利用率高和传统虚拟机不同，Docker 容器直接运行在宿主机的内核上，不需要额外的操作系统开销。这意味着多个容器可以共享同一个宿主机的操作系统资源，从而提高资源利用率。例如，在一台服务器上可以同时运行多个不同的 Docker 容器，每个容器运行一个独立的应用，它们之间相互隔离，但又共享服务器的硬件资源，降低了硬件成本。\n快速部署与扩展Docker 容器的启动速度非常快，通常只需几秒钟，这使得应用的部署变得高效。而且，当应用的访问量增加时，可以通过复制容器来快速扩展应用的处理能力。例如，在电商网站的促销活动期间，可以迅速增加运行应用的容器数量，以应对高并发的访问请求。\n隔离性与安全性每个 Docker 容器都是相互隔离的，一个容器的故障不会影响其他容器的运行。同时，容器提供了一定程度的安全隔离，减少了应用之间的相互影响。例如，在一个多租户的环境中，不同租户的应用可以运行在各自的 Docker 容器中，避免了相互干扰和数据泄露的风险。\n版本控制与回滚Docker 镜像支持版本控制，你可以为每个镜像版本打上标签，方便管理和追踪。如果应用出现问题，可以轻松回滚到之前的镜像版本。例如，当你对应用进行了更新，但发现新的版本存在 bug 时，可以迅速将容器回滚到上一个稳定的镜像版本。\n便于团队协作在团队开发中，Docker 可以提供统一的开发环境。开发人员可以基于同一个 Docker 镜像进行开发，避免了因环境差异导致的问题。同时，运维人员也可以使用相同的镜像进行部署，提高了团队协作的效率。例如，开发团队和运维团队可以通过共享 Docker 镜像来确保应用的开发和部署流程的一致性\n\ndocker的操作CentOS 系统上安装 Docker卸载旧版本（如果有）sudo yum remove docker \\                  docker-client \\                  docker-client-latest \\                  docker-common \\                  docker-latest \\                  docker-latest-logrotate \\                  docker-logrotate \\                  docker-engine\n设置 Docker 软件源sudo yum install -y yum-utilssudo yum-config-manager \\    --add-repo \\    https://download.docker.com/linux/centos/docker-ce.repo\n安装 Dockersudo yum install docker-ce docker-ce-cli containerd.io -y\n启动并设置 Docker 开机自启sudo yum install docker-ce docker-ce-cli containerd.io -y\n验证 Docker 是否安装成功sudo docker run hello-world\ndocker的操作镜像操作搜索镜像若要从 Docker Hub 搜索所需镜像，可使用 docker search 命令。例如搜索 nginx 镜像：\ndocker search nginx\n拉取镜像使用 docker pull 命令从 Docker 仓库拉取镜像。以拉取 nginx 官方最新版本镜像为例：\ndocker pull nginx\n若要指定版本，可在镜像名后加冒号和版本号，如拉取 nginx 1.21.6 版本：\ndocker pull nginx:1.21.6\n查看本地镜像使用 docker images 命令查看本地已有的镜像：\ndocker images\n删除本地镜像使用 docker rmi 命令删除本地镜像。例如删除 nginx 镜像：\ndocker rmi nginx\n构建镜像可以使用 Dockerfile 构建自定义镜像。假设已有一个简单的 Dockerfile，可在其所在目录下执行 docker build 命令构建镜像：\ndocker build -t my-nginx:1.0 .\n其中 -t 用于指定镜像的名称和标签，. 表示使用当前目录下的 Dockerfile。\n容器操作创建并启动容器使用 docker run 命令创建并启动容器。例如启动一个 nginx 容器：\ndocker run -d -p 8080:80 nginx\n其中 -d 表示让容器在后台运行，-p 8080:80 表示将宿主机的 8080 端口映射到容器的 80 端口。\n查看运行中的容器使用 docker ps 命令查看当前正在运行的容器：\ndocker ps\n若要查看所有容器（包括已停止的），可使用 docker ps -a 命令。\n停止容器使用 docker stop 命令停止运行中的容器。例如停止名为 my-nginx-container 的容器：\ndocker stop my-nginx-container\n启动已停止的容器使用 docker start 命令启动已停止的容器：\ndocker start my-nginx-container\n进入容器使用 docker exec 命令进入正在运行的容器。例如进入 my-nginx-container 容器的交互式终端：\ndocker exec -it my-nginx-container /bin/bash\n其中 -it 表示以交互式终端模式进入容器。\n删除容器使用 docker rm 命令删除已停止的容器：\ndocker rm my-nginx-container\n若要删除正在运行的容器，可添加 -f 选项强制删除：\ndocker rm -f my-nginx-container\n仓库操作登录 Docker 仓库使用 docker login 命令登录 Docker 仓库：\ndocker login\n之后按照提示输入用户名和密码。\n推送镜像到仓库先给本地镜像打标签，使其符合仓库的命名规则，再使用 docker push 命令推送镜像。例如将本地的 my-nginx:1.0 镜像推送到 Docker Hub：\ndocker tag my-nginx:1.0 your-dockerhub-username/my-nginx:1.0docker push your-dockerhub-username/my-nginx:1.0\n\n结语1、了解什么docker技术2、为什么要使用docker技术3、centos 上部署docker服务4、docker的操作类型(镜像、容器、仓库)","categories":["Sever"],"tags":["Cloud"]},{"title":"Linux的命令","url":"/2022/07/22/14.Linux/","content":"前言这里只是简单介绍Linux及其命令\n\nLinux 系统概述Linux 是一种开源的类 Unix 操作系统内核，广泛应用于服务器、嵌入式设备和个人计算机。其核心特点包括：\n\n多用户&#x2F;多任务：支持多用户同时操作和并行任务处理\n文件系统：采用树状目录结构（&#x2F; 为根目录）\n权限管理：严格的用户权限控制机制\n命令行界面：通过 Shell 实现高效系统操作\n\n\n核心命令分类详解文件与目录操作\n\n\n命令\n功能说明\n常用参数示例\n\n\n\nls\n列出目录内容\n-l 详细信息-a 显示隐藏文件\n\n\ncd\n切换工作目录\ncd ~ 返回家目录cd .. 返回上级目录\n\n\ncp\n复制文件&#x2F;目录\n-r 递归复制目录-i 覆盖前提示\n\n\nmv\n移动&#x2F;重命名文件\nmv old.txt new.txt\n\n\nrm\n删除文件\n-rf 强制递归删除-i 交互式删除\n\n\nmkdir\n创建目录\n-p 创建多级目录\n\n\nfind\n文件搜索\nfind / -name &quot;*.log&quot;\n\n\n系统信息与管理\n\n\n命令\n功能说明\n使用示例\n\n\n\ntop\n实时进程监控\n按 P 按CPU排序\n\n\nps\n进程查看\nps aux 显示所有进程\n\n\nkill\n终止进程\nkill -9 PID 强制终止\n\n\ndf\n磁盘空间查看\ndf -h 人性化显示\n\n\nfree\n内存使用情况\nfree -m 以MB为单位\n\n\nuname\n系统信息\nuname -a 显示全部信息\n\n\n网络相关命令\n\n\n命令\n功能说明\n典型应用场景\n\n\n\nping\n网络连通性测试\nping google.com\n\n\nifconfig\n网络接口配置\n（已逐步被 ip 命令替代）\n\n\nnetstat\n网络状态查看\nnetstat -tulnp 查看监听端口\n\n\ncurl\n数据传输工具\ncurl -O http://example.com/file\n\n\nwget\n文件下载\nwget -c 断点续传\n\n\nssh\n安全远程登录\nssh user@host\n\n\n权限管理命令\n\n\n命令\n功能说明\n权限表示法\n\n\n\nchmod\n修改文件权限\nchmod 755 filechmod u+x script.sh\n\n\nchown\n修改文件所有者\nchown user:group file\n\n\nsudo\n以管理员权限执行\nsudo apt update\n\n\npasswd\n修改用户密码\npasswd username\n\n\n软件包管理APT (Debian&#x2F;Ubuntu)sudo apt update          # 更新软件源列表sudo apt install nginx  # 安装软件包sudo apt remove vim     # 移除软件包\n\nYUM (CentOS&#x2F;RHEL)sudo yum check-update   # 检查更新sudo yum install httpd  # 安装软件sudo yum remove mysql   # 移除软件\n\n文本处理命令\n\n\n命令\n功能说明\n管道组合示例\n\n\n\ngrep\n文本搜索\n&#96;ps aux\n\n\ncat\n显示文件内容\ncat file.txt\n\n\nvim\n文本编辑器\nvim /etc/hosts\n\n\nawk\n文本分析处理\nawk &#39;&#123;print $1&#125;&#39; access.log\n\n\nsed\n流编辑器\nsed &#39;s/old/new/g&#39; file.txt\n\n\n压缩与归档tar -czvf archive.tar.gz /path   # 创建gzip压缩包tar -xzvf archive.tar.gz        # 解压gzip包zip -r backup.zip directory     # 创建zip压缩包unzip backup.zip               # 解压zip文件\n\n\n#命令使用注意事项\n\n危险操作警示：\nrm -rf / 会删除整个系统\nchmod 777 会开放全部权限\n\n\n权限升级原则：\n优先使用普通用户操作\n慎用 sudo 执行未知命令\n\n\n操作确认机制：\n使用 -i 参数进行交互确认\n重要文件先备份再操作\n\n\n\n\n命令应用场景对比\n\n\n场景\n推荐命令组合\n\n\n\n日志分析\n&#96;grep “ERROR” logfile\n\n\n系统监控\nwatch -n 1 &quot;free -m &amp;&amp; df -h&quot;\n\n\n批量重命名\nfind . -name &quot;*.txt&quot; -exec mv &#123;&#125; &#123;&#125;.bak \\;\n\n\n网络调试\ntcpdump -i eth0 -w capture.pcap\n\n\n\n学习资源推荐\n官方文档：man [command]\n在线教程：Linux Journey (linuxjourney.com)\n经典书籍：《鸟哥的Linux私房菜》\n交互练习：OverTheWire 战争游戏\n\n\n总结\n按功能分类组织命令\n包含危险操作警示\n提供典型应用场景\n区分不同发行版的包管理\n强调命令组合使用技巧\n推荐系统学习路径\n\n可根据实际需要调整命令范围和详细程度，建议配合实际操作练习掌握。\n\n","categories":["Linux"],"tags":["OS"]},{"title":"KVM","url":"/2022/09/10/16.KVM/","content":"前言我这里是使用的是CentOS 7 ,由于linux发行版本问题，可能有出入，请多包涵\n\nKVM 简介KVM（Kernel-based Virtual Machine）是基于 Linux 内核的开源虚拟化解决方案，特点如下：\n\n内核集成：直接利用 Linux 内核作为 Hypervisor，无需额外内核。\n硬件支持：依赖 CPU 虚拟化扩展（Intel VT-x&#x2F;AMD-V），性能接近物理机。\n多平台兼容：支持 Windows、Linux 等多种操作系统作为虚拟机。\n管理灵活：可通过命令行（virsh）或图形工具（virt-manager）管理。\n\n\nCentOS7 搭建 KVM 步骤1. 环境准备# 检查 CPU 是否支持虚拟化（输出应 ≥1）egrep -c &#x27;(vmx|svm)&#x27; /proc/cpuinfo# 安装软件包组yum groupinstall &quot;Virtualization Host&quot; -yyum install qemu-kvm libvirt virt-install bridge-utils -y# 启动服务systemctl start libvirtd &amp;&amp; systemctl enable libvirtd# 添加用户到 libvirt 组usermod -aG libvirt $USER\n创建虚拟机# 示例：创建一个 2CPU/2GB 内存/20GB 磁盘的虚拟机virt-install \\--name=centos7-vm \\--vcpus=2 \\--memory=2048 \\--disk path=/var/lib/libvirt/images/centos7.qcow2,size=20,format=qcow2 \\--cdrom=/path/to/CentOS-7-x86_64-Minimal.iso \\--os-type=linux \\--os-variant=centos7 \\--network network=default \\--graphics vnc,port=5901\n连接虚拟机\n使用 VNC 客户端连接 宿主机IP:5901\n或通过 virsh console &lt;VM_NAME&gt; 进入控制台\n\n\n常用 KVM 命令虚拟机操作\n基本管理：virsh list --all        # 列出所有虚拟机virsh start &lt;VM_NAME&gt;   # 启动虚拟机virsh shutdown &lt;VM_NAME&gt;  # 正常关机virsh destroy &lt;VM_NAME&gt; # 强制断电virsh undefine &lt;VM_NAME&gt; # 删除配置\n配置编辑：virsh edit &lt;VM_NAME&gt;    # 修改虚拟机 XML 配置文件virsh dumpxml &lt;VM_NAME&gt; &gt; vm.xml  # 导出配置\n\n存储管理\n创建虚拟磁盘：qemu-img create -f qcow2 /data/vm_disk.img 50G\n存储池操作：virsh pool-define-as mypool dir --target /data/kvm_pools  # 定义存储池virsh pool-start mypool   # 激活存储池\n\n网络管理\n查看网络：virsh net-list --all      # 列出所有虚拟网络virsh net-info default    # 查看默认网络信息\n创建桥接网络：# 编辑网卡配置文件（如 br0）nmcli connection add type bridge con-name br0 ifname br0\n\n\n四、核心总结\nKVM 优势：\n\n开源免费，性能接近物理机\n与 Linux 生态深度集成\n支持动态迁移、快照等高级功能\n\n\n适用场景：\n\n企业服务器虚拟化\n开发&#x2F;测试环境隔离\n云平台底层虚拟化（如 OpenStack）\n\n\n关键注意点：\n\n确保 CPU 支持虚拟化并开启 BIOS 设置\n使用 qcow2 格式磁盘节省空间\n优先配置桥接网络实现外网访问\n\n\n\n\n","categories":["Linux"],"tags":["OS"]},{"title":"在macOS上配C/C++","url":"/2022/10/15/17.macOS_C++/","content":"前言我这里是macOS Catalina（10.15），如果是macOS 11（big sur） 和 macOS 12（Monterey）也适用。老版本的macOS有些不被支持，请查阅相关文档安装 Xcode 命令行工具# 终端执行以下命令安装xcode-select --install# 弹出窗口点击&quot;Install&quot;确认安装，等待完成\n\n安装 C++ 编译器选项 1: 使用 Xcode 自带的 Clang++# 验证安装（安装后执行）clang++ --version\n选项 2: 安装 GCC# 通过 Homebrew 安装最新 GCCbrew install gcc# 验证安装（例如安装的是 gcc-13）g++-13 --version\n\n安装构建工具安装 CMakebrew install cmake\n\n安装 Make（通常已预装）make --version  # 验证是否已存在\n\n安装 IDE&#x2F;编辑器VS Codebrew install --cask visual-studio-code# 扩展推荐：C/C++, CMake, Code Runner\n\nCLion（JetBrains 专业 IDE）brew install --cask clion\n\n验证开发环境创建测试文件 test.cpp:\n#include &lt;iostream&gt;int main() &#123;    std::cout &lt;&lt; &quot;Hello, C++ on macOS!&quot; &lt;&lt; std::endl;    return 0;&#125;\n编译运行：\n# 使用 Clang++clang++ test.cpp -o test &amp;&amp; ./test# 使用 GCC（假设安装的是 g++-13）g++-13 test.cpp -o test_gcc &amp;&amp; ./test_gcc\n\n常见问题\nxcode-select 报错尝试强制安装：sudo xcode-select --reset\n\ncommand not found: g++检查是否将 GCC 路径加入环境变量：echo &#39;export PATH=&quot;/usr/local/opt/gcc/bin:$PATH&quot;&#39; &gt;&gt; ~/.zshrc\n\n权限问题避免使用 sudo 编译，建议在用户目录开发\n\n\n\n总结✅ 完整配置流程命令行工具 → 编译器 → 构建工具 → IDE → 验证\n🔧 工具选择建议\n\n新手推荐：Clang++ + VS Code\n大型项目推荐：GCC + CLion📦 环境管理技巧\n使用 brew update 定期更新工具链\n通过 alias 简化编译命令现在可以开始你的 C++ 开发之旅了！ 🚀\n\n\n","categories":["macOS"],"tags":["Coding"]},{"title":"markdown指南","url":"/2022/08/12/15.markdown/","content":"前言这里只是简单介绍 Markdown 语言简介与编辑器推荐\n\nMarkdown 是什么Markdown 是一种轻量级的标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。它在编写文档、博客、论坛帖子等方面非常受欢迎，因为它的语法简洁，易于学习和使用。\n\nMarkdown 语言语法标题使用不同数量的#符号来表示不同级别的标题，从#（一级标题）到######（六级标题）。\n# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n文本格式• 加粗：使用**或__包裹文字，例如：**加粗的文字**或__加粗的文字__。• 斜体：使用*或_包裹文字，例如：*斜体的文字*或_斜体的文字_。• 删除线：使用~~包裹文字，例如：~~删除的文字~~。\n列表• 无序列表：使用-、*或+开头，例如：\n- 项目一* 项目二+ 项目三\n• 有序列表：使用数字加点开头，例如：\n1. 第一项2. 第二项3. 第三项\n链接使用[链接描述](链接地址)的格式，例如：[百度](https://www.baidu.com)。\n图片使用![图片描述](图片链接)的格式，例如：![示例图片](https://example.com/image.jpg)。\n表格使用|和-来创建表格，例如：\n| 列1 | 列2 | 列3 || --- | --- | --- || 内容1 | 内容2 | 内容3 || 内容4 | 内容5 | 内容6 |\n代码块• 行内代码：使用单个反引号`包裹代码，例如：console.log(&quot;Hello, World!&quot;);。• 代码块：使用三个反引号&#96;&#96;&#96; &#96;&#96;&#96;&#96;包裹代码，例如：\nconsole.log(&quot;Hello,World!&quot;);\n\nMarkdown 编辑器推荐Typora• 特点：所见即所得，界面简洁美观，支持多种格式的导出（如 PDF、HTML 等）。• 适用人群：适合新手和需要快速输出文档的用户。\nVS Code（Visual Studio Code）• 特点：功能强大，支持多种编程语言和插件，可以通过安装 Markdown 插件来增强 Markdown 编辑功能。• 适用人群：适合程序员和对编辑器功能有较高要求的用户。\nObsidian• 特点：强调知识管理和笔记整理，支持 Markdown 编辑，适合构建个人知识库。• 适用人群：适合知识工作者和笔记爱好者。\n\n总结Markdown 是一种简单而强大的标记语言，它可以帮助我们快速编写和格式化文档。通过掌握其基本语法，我们可以轻松地创建出结构清晰、格式规范的文本。同时，选择合适的 Markdown 编辑器可以进一步提升我们的写作效率和体验。希望这篇文章能帮助你更好地了解和使用 Markdown。\n\n","categories":["Program Language"],"tags":["markdown"]},{"title":"SQL 手册","url":"/2022/12/03/19.SQL/","content":"前言这里只是简单介绍 SQL 语言简介与简单使用\n一、SQL 语言简介SQL（Structured Query Language）是一种用于管理关系型数据库管理系统（RDBMS）的标准编程语言。主要功能包括：\n\n数据定义：创建&#x2F;修改数据库结构（表、索引等）\n数据操作：增删改查（CRUD）数据\n数据控制：权限管理和事务控制\n数据查询：复杂数据检索与分析\n\n核心特点：\n声明式语言：只需描述”做什么”，无需指定”怎么做”\nANSI 标准：跨平台兼容（MySQL, PostgreSQL, SQL Server, Oracle 等）\n分层语法：\nDDL：数据定义语言\nDML：数据操作语言\nDCL：数据控制语言\nTCL：事务控制语言\n\n\n\n\n二、SQL 使用手册1. 数据定义语言（DDL）-- 创建数据库CREATE DATABASE company_db;-- 创建表CREATE TABLE employees (    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(50) NOT NULL,    department VARCHAR(50),    salary DECIMAL(10,2),    hire_date DATE);-- 修改表结构ALTER TABLE employees ADD COLUMN email VARCHAR(100);-- 删除表DROP TABLE temp_data;\n\n2. 数据操作语言（DML）-- 插入数据INSERT INTO employees (name, department, salary, hire_date)VALUES (&#x27;张三&#x27;, &#x27;技术部&#x27;, 15000.00, &#x27;2023-01-15&#x27;);-- 更新数据UPDATE employees SET salary = salary * 1.1 WHERE department = &#x27;技术部&#x27;;-- 删除数据DELETE FROM employees WHERE hire_date &lt; &#x27;2020-01-01&#x27;;-- 查询数据（基础）SELECT name, department, salary FROM employees WHERE salary &gt; 10000 ORDER BY hire_date DESC;\n\n3. 高级查询技巧-- 聚合函数SELECT     department,     AVG(salary) AS avg_salary,    COUNT(*) AS employee_countFROM employeesGROUP BY departmentHAVING AVG(salary) &gt; 12000;-- 多表连接SELECT     e.name,     d.department_name,    p.project_nameFROM employees eJOIN departments d ON e.department_id = d.idLEFT JOIN projects p ON e.id = p.lead_id;-- 子查询SELECT name, salaryFROM employeesWHERE salary &gt; (    SELECT AVG(salary)     FROM employees);-- 分页查询（MySQL语法）SELECT * FROM employeesORDER BY hire_dateLIMIT 10 OFFSET 20;  -- 跳过20条取10条\n\n4. 数据控制语言（DCL）-- 创建用户CREATE USER &#x27;data_analyst&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;secure_pwd&#x27;;-- 授予权限GRANT SELECT ON company_db.* TO &#x27;data_analyst&#x27;@&#x27;localhost&#x27;;-- 撤销权限REVOKE DELETE ON company_db.salary_data FROM &#x27;data_analyst&#x27;@&#x27;localhost&#x27;;-- 删除用户DROP USER &#x27;intern_user&#x27;@&#x27;localhost&#x27;;\n\n5. 事务控制（TCL）START TRANSACTION;UPDATE accounts SET balance = balance - 500 WHERE id = 1001;UPDATE accounts SET balance = balance + 500 WHERE id = 2002;-- 提交或回滚COMMIT;  -- 确认执行-- ROLLBACK;  -- 撤销操作\n\n6. 常用函数速查\n\n\n类型\n函数示例\n功能描述\n\n\n\n聚合函数\nSUM(), AVG()\n求和&#x2F;平均值\n\n\n\nCOUNT(), MAX/MIN()\n计数&#x2F;极值\n\n\n字符串函数\nCONCAT(), SUBSTR()\n拼接&#x2F;截取字符串\n\n\n\nUPPER(), TRIM()\n大小写转换&#x2F;去空格\n\n\n日期函数\nNOW(), DATE_FORMAT()\n当前时间&#x2F;格式化日期\n\n\n\nDATEDIFF(), YEAR()\n日期差&#x2F;提取年份\n\n\n条件函数\nCASE...WHEN\n条件分支\n\n\n\nCOALESCE(), IFNULL()\n空值处理\n\n\n\n三、SQL 最佳实践\n索引优化：\nCREATE INDEX idx_department ON employees(department);-- 避免全表扫描\n\n防注入攻击：\n-- 使用参数化查询而非字符串拼接-- 错误示例： &quot;SELECT * FROM users WHERE id = &quot; + user_input\n\n命名规范：\n\n表名&#x2F;列名使用蛇形命名法（employee_id）\n保留字使用反引号包裹（`order`）\n\n\n性能提示：\n\n避免SELECT * → 明确指定所需列\n用EXISTS替代IN处理大数据集\n定期使用EXPLAIN分析查询计划\n\n\n\n\n四、总结SQL 作为关系型数据库的核心交互语言，具有以下关键价值：✅ 高效数据管理：通过简洁语法实现复杂数据操作✅ 标准化接口：跨数据库平台的通用技能（需注意方言差异）✅ 强扩展性：支持从基础CRUD到高级分析（窗口函数、CTE等）✅ 安全可控：完善的权限体系和事务机制保障数据安全\n\n学习建议：\n\n先掌握基础DDL&#x2F;DML语法\n精通多表连接和聚合查询\n了解特定数据库的扩展语法（如MySQL的LIMIT，SQL Server的TOP）\n通过EXPLAIN深入理解执行机制\n在真实项目中实践优化技巧\n\n\n\n","categories":["Program Language"],"tags":["Coding"]},{"title":"C/C++ 编程环境全指南","url":"/2022/11/01/18.%20C&C++%20%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83/","content":"主要编程环境分类集成开发环境（IDE）\n\n\n工具名称\n支持系统\n特性\n适用场景\n\n\n\nVisual Studio\nWindows&#x2F;macOS（有限）\n微软官方工具链，强大调试器，MSVC编译器\nWindows原生开发、大型项目\n\n\nCLion\nWin&#x2F;macOS&#x2F;Linux\n跨平台CMake支持，智能代码分析\n跨平台项目开发\n\n\nEclipse CDT\nWin&#x2F;macOS&#x2F;Linux\n免费开源，插件生态系统\n教育&#x2F;嵌入式开发\n\n\nCode::Blocks\nWin&#x2F;macOS&#x2F;Linux\n轻量级，内置MinGW\n小型项目&#x2F;教学场景\n\n\n编辑器+编译器组合\n\n\n组合方案\n核心组件\n优势\n\n\n\nVSCode + GCC\nVSCode + GNU工具链\n高度可定制化，跨平台支持\n\n\nVim&#x2F;Emacs\n编辑器+GDB&#x2F;Clang\n终端友好，适合Linux服务器开发\n\n\nSublime Text\nST + 自定义构建系统\n轻量快速响应\n\n\n\n系统级优化方案Windows 平台\n推荐方案：Visual Studio 2022\n优势：\n深度集成Windows SDK\n最佳MSVC编译器支持\nDirectX开发工具链\n\n\n\nmacOS 平台\n推荐方案：Xcode + CLion\n优势组合：\nXcode提供完整Clang工具链\nCLion增强跨平台开发体验\n\n\n\nLinux 平台\n推荐方案：VSCode + GCC&#x2F;GDB\n扩展建议：\nC&#x2F;C++ Extension Pack\nCMake Tools\nGitLens\n\n\n\n\n性能对比分析\n\n\n指标\nVisual Studio\nCLion\nVSCode\nVim\n\n\n\n启动速度\n★★☆☆☆\n★★★☆☆\n★★★★☆\n★★★★★\n\n\n调试能力\n★★★★★\n★★★★☆\n★★★★☆\n★★☆☆☆\n\n\n内存占用\n2GB+\n1.5GB\n800MB\n&lt;100MB\n\n\n跨平台支持\n有限\n完全\n完全\n完全\n\n\n\n参考文献\nStroustrup B.《C++程序设计语言（第4版）》: 编译器原理章节\nMicrosoft Docs: Visual Studio官方文档体系\nGNU Compiler Collection: gcc.gnu.org&#x2F;onlinedocs\nCLion官方白皮书: jetbrains.com&#x2F;clion&#x2F;features\nStack Overflow 2023开发者调查报告\n\n\n总结建议\n企业级开发：优先考虑Visual Studio（Windows）或CLion（跨平台）\n教育&#x2F;轻量级：Code::Blocks&#x2F;VSCode组合\n服务器&#x2F;Linux：Vim&#x2F;VSCode + GCC工具链\n跨平台需求：CLion &gt; VSCode &gt; Qt Creator配置建议矩阵：\n\n\n使用场景\n推荐工具\n配置建议\n\n\n\nWindows游戏开发\nVisual Studio\n安装Windows 10 SDK + DirectX\n\n\n跨平台库开发\nCLion + CMake\n配置WSL开发环境\n\n\n算法竞赛\nVSCode + Competitive\n安装Code Runner扩展\n\n\n内核开发\nVim + GDB\n配置cscope&#x2F;ctags\n\n\n\n\n","categories":["Program Language"],"tags":["Coding"]},{"title":"VScode配置C/C++(windows版本)","url":"/2021/07/08/2.VScode/","content":"前言我这里是Windows10&#x2F;11专业工作版(其他Windows版本也适用)如果你的设备是已经是结束支持的Windows7，请查阅其他相关是手册配置C&#x2F;C++语言需要一个编辑器(Editor)和一个编译环境(Intergrated Development Environment)编辑器(Editor):可以以简单的理解为：可以写代码的地方，并且可以实现代码的DeBug等其他功能编译环境(Intergrated Development Environment)：简称IDE，可以以简单的理解为将代码编译为计算机能理解的语句需要下载的软件的  MinGW(GCC) 、 Microsoft Visual Studio CodeMinGW(GCC)GCC是什么？GCC（GNU Compiler Collection，GNU编译器套件）是由GNU开发的编程语言编译器。GNU编译器套件包括C、C++、 Objective-C、 Fortran、Java、Ada和Go语言前端，也包括了这些语言的库（如libstdc++，libgcj等。）GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由\n如何下载GCCGCC官网下下载链接,点击这个连接就可以跳转到GCC官方下载的界面下载的时候有两个版本可以选择，一个是标准版，一个是withou-git版本，按照自己的需求下载就好了这里我下载的是标准版的\n安装GCC将下载好了的 gcc安装好，到自己电脑的某个位置，并记住 GCC 的安装位置找到 GCC 的位置，进入bin文件，在Windows的文件管理器中的地址栏复制该路径例如： E:\\IDEs\\GCC\\MinGW\\bin\n配置GCC到电脑的path环境变量中鼠标右键点击此电脑，选择属性，找到高级系统设置，进入他，点击环境变量（或者使用快捷键n）这里会发现有两个path，一个是用户的环境变量，一个是系统的环境变量，选择用户的环境变量，注意是用户的，用户的，用户的（重要是事情说三遍！！！）进入用户的path环境变量中，新建（或者使用快捷键n）一个值，将刚刚的地址粘贴上去\n检测GCC是否在全局中可以访问使用打开运行框（或者使用快捷键 win + r），输入cmd,打开Windows控制台，输入   gcc  --version返回GCC的版本号将GCC在Windows中可以全局访问了如果没有返回就请重新检查一下前面的步骤Microsoft Visual Studio Code什么是Microsoft Visual Studio CodeMicrosoft Visual Studio Code（简称“VS Code” 或 “MVSC”，以下简称“VS code”）。是Microsoft在2015年4月30日Build开发者大会上正式宣布一个运行于 Mac OS X、Windows和 Linux 之上的。针对于编写现代Web和云应用的跨平台源代码编辑器，可在桌面上运行，并且可用于Windows，macOS和Linux。它具有对JavaScript，TypeScript和Node.js的内置支持，并具有丰富的其他语言（例如C++，C＃，Java，Python，PHP，Go）和运行时（例如.NET和Unity）扩展的生态系统。\n下载Microsoft Visual Studio CodeVS code官网下下载链接,点击池连接就可以跳转到VS code官方下载的界面下载的时候有两个版本可以选择，insider(业内人)和stable(稳定版)，按照自己的想法选择，建议：初学者选择Stable版本\n安装Microsoft Visual Studio Code直接点击下载好了的安装包，一直点击下一步，全部都可以勾选，然后安装结束，运行 VS code\n配置Microsoft Visual Studio Code在VS code中可以选择自己喜欢的主题颜色，如果看不懂英文可以在这边的选择栏中选择Extensions（扩展）。在搜索框中搜索 Chinese ，选择Chinese （Simplified）（中文简体），如果你是港澳台地区选择Chinese （Traditional）（中文繁体），按需选择就好。install刚刚选择好了的语言，会弹出 “Change Language and Restart”，点击它，然后VS code重启，重启后就是你选择的语言了。继续在xtensions（扩展）搜索C&#x2F;C++ Extension pack，install（安装）它，就配置好了\nMicrosoft Visual Studio Code 相关插件VS code运行C&#x2F;C++的时候需要安装一个code runner插件！！！小结1：下载 GCC  和  Microsoft Visual Studio Code2：安装 GCC  和  Microsoft Visual Studio Code3：配置、验证 GCC 是否在Windows全局可以访问4：配置 Microsoft Visual Studio Code ，在Extensions（扩展）中安装字体和 C&#x2F;C++ Extension pack","categories":["Program Language"],"tags":["Coding"]},{"title":"简单认识CentOS7","url":"/2023/02/03/21.CentOS7/","content":"一、CentOS 7 简介CentOS 7（Community Enterprise Operating System）是基于 Red Hat Enterprise Linux (RHEL) 7 源代码构建的免费开源企业级 Linux 发行版。由社区驱动开发维护，于2014年7月发布，提供长期支持至2024年6月30日。\n核心特性与架构升级：\n内核与初始化系统：\n\n采用 Linux 3.10 内核\n使用 systemd 替代传统的 SysVinit（启动速度提升2倍）\n默认文件系统 XFS（支持最大500TB单文件）\n\n\n网络与安全：\n\n防火墙管理工具 firewalld（动态区域管理）\n默认启用 SELinux（增强安全策略）\n支持 NetworkManager 统一网络管理\n\n\n服务管理革新：\n\nsystemctl 命令替代 service&#x2F;chkconfig\n\nsystemctl start httpd      # 启动服务systemctl enable httpd     # 设置开机自启\n\n虚拟化与容器：\n\n集成 KVM 虚拟化技术\n原生支持 Docker 容器（通过 yum install docker）\n提供 OpenStack 云计算组件\n\n\n\n\n二、关键技术亮点1. 系统启动流程优化graph LRA[UEFI/SecureBoot] --&gt; B[systemd]B --&gt; C[并行启动服务]C --&gt; D[图形/命令行登录]\n\n2. 软件包管理（YUM&#x2F;DNF）# 安装软件sudo yum install nginx# 更新系统sudo yum update# 查看软件信息yum info httpd\n\n3. 存储管理革新\nLVM 默认启用：支持在线卷调整\n引入 Stratis：高级存储管理（类似ZFS&#x2F;Btrfs）\n支持 VDO（虚拟数据优化器）：重复数据删除\n\n\n三、CentOS 7 总结核心优势：✅ 企业级稳定性：严格的测试流程保障系统可靠性✅ 长期支持：10年生命周期（5年全支持+5年维护）✅ RHEL 兼容性：100% 二进制兼容，无缝迁移企业应用✅ 丰富生态：EPEL仓库提供额外8000+软件包✅ 零成本：完全免费获取和使用\n典型应用场景：\n企业服务器&#x2F;数据中心\nWeb服务托管（Apache&#x2F;Nginx）\n数据库服务器（MySQL&#x2F;PostgreSQL）\n虚拟化平台（KVM&#x2F;OpenStack）\n容器化应用基础平台\n\n生命周期时间线：timeline    title CentOS 7 生命周期    section 支持周期    2014-07 ： 正式发布    2019-08 ： 结束完整更新    2024-06 ： 终止所有支持\n\n\n历史地位：作为 CentOS 传统版本的最终主线发行版，CentOS 7 在 Linux 服务器领域占据主导地位多年。\n\n迁移建议：\n现有用户：2024年6月前迁移至 CentOS Stream&#x2F;Rocky Linux&#x2F;AlmaLinux\n新部署：推荐选择 CentOS Stream 9 或其他 RHEL 衍生版\n学习价值：仍是理解企业 Linux 生态的最佳学习平台最终评价：CentOS 7 以其卓越的稳定性、免费的企业级功能和强大的社区支持，成为 Linux 服务器发展史上的里程碑版本，为全球数百万服务器提供坚实基石。\n\n\n","categories":["Linux"],"tags":["CentOS"]},{"title":"个人FTP服务器","url":"/2023/01/15/20.ftp/","content":"前言这里只是简单介绍与搭建ftp服务器！！！\n\n一、FTP 服务器简介FTP（File Transfer Protocol）是一种用于在客户端与服务器之间传输文件的标准网络协议。它使用两个通道：\n\n命令通道（默认端口21）：传输控制指令\n数据通道（动态端口）：实际传输文件内容\n\n核心特点：\n跨平台支持：Windows&#x2F;Linux&#x2F;macOS 均可使用\n两种工作模式：\n主动模式：服务器主动连接客户端（易受防火墙阻挡）\n被动模式：客户端连接服务器（推荐现代网络环境）\n\n\n常见实现方案：\nvsftpd（Very Secure FTP Daemon）：轻量级、安全\nProFTPD：高度可配置\nPure-FTPd：专注于安全\n\n\n\n典型应用场景：\n网站文件上传&#x2F;下载\n企业内部文件共享\n自动化备份传输\n跨平台文件交换\n\n\n二、CentOS7 搭建 vsftpd 服务器指南1. 环境准备# 更新系统sudo yum update -y# 检查防火墙状态sudo systemctl status firewalld# 开放FTP服务端口（永久生效）sudo firewall-cmd --permanent --add-service=ftpsudo firewall-cmd --reload\n2. 安装 vsftpd# 安装vsftpdsudo yum install vsftpd -y# 启动服务并设置开机自启sudo systemctl start vsftpdsudo systemctl enable vsftpd# 验证服务状态sudo systemctl status vsftpd\n3. 基础配置（编辑配置文件）sudo vi /etc/vsftpd/vsftpd.conf\n# 核心配置项修改：anonymous_enable=NO          # 禁止匿名登录local_enable=YES             # 允许本地用户登录write_enable=YES             # 启用写权限local_umask=022              # 新建文件权限掩码dirmessage_enable=YES        # 显示目录消息xferlog_enable=YES           # 启用传输日志connect_from_port_20=YES     # 使用20端口传输xferlog_std_format=YES       # 标准日志格式# 添加以下配置：pasv_enable=YES              # 启用被动模式pasv_min_port=30000          # 被动模式最小端口pasv_max_port=31000          # 被动模式最大端口allow_writeable_chroot=YES    # 允许chroot可写# 保存退出后重启服务sudo systemctl restart vsftpd\n\n4. 用户管理# 创建FTP专用用户（例如ftpuser）sudo useradd -m -d /var/ftp/ftpuser -s /sbin/nologin ftpusersudo passwd ftpuser  # 设置密码# 配置用户目录权限sudo chmod 750 /var/ftp/ftpusersudo chown ftpuser: /var/ftp/ftpuser# 限制用户访问范围（可选）echo &quot;ftpuser&quot; | sudo tee -a /etc/vsftpd/user_list\n\n5. 防火墙配置（开放被动模式端口）sudo firewall-cmd --permanent --add-port=30000-31000/tcpsudo firewall-cmd --reload\n\n6. SELinux 调整# 允许FTP访问用户目录sudo setsebool -P ftp_home_dir on# 如果使用非标准目录sudo semanage fcontext -a -t public_content_t &quot;/var/ftp(/.*)?&quot;sudo restorecon -Rv /var/ftp\n\n7. 客户端连接测试\nLinux 客户端：\nftp your_server_ip# 输入用户名密码put testfile.txt  # 上传测试\n\nWindows 客户端：\n\n文件资源管理器地址栏输入：ftp://your_server_ip\n使用 FileZilla（推荐）：输入主机&#x2F;用户名&#x2F;密码\n\n\n\n\n三、安全加固建议1. 加密传输（FTPS）# 在vsftpd.conf中添加：ssl_enable=YESallow_anon_ssl=NOforce_local_logins_ssl=YESforce_local_data_ssl=YESrsa_cert_file=/etc/vsftpd/vsftpd.pem\n\n生成证书：\nsudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \\-keyout /etc/vsftpd/vsftpd.pem -out /etc/vsftpd/vsftpd.pem\n\n2. 访问控制# 限制用户在家目录（默认开启）chroot_local_user=YES# 使用访问列表userlist_enable=YESuserlist_deny=NO  # 仅允许列表中的用户\n\n3. 其他安全措施\n定期更新vsftpd：sudo yum update vsftpd\n使用强密码策略\n禁用root登录\n启用传输日志审计\n\n\n四、常见问题排查1. 连接超时\n检查防火墙：sudo firewall-cmd --list-all\n验证端口开放：telnet your_server_ip 21\n\n2. 认证失败\n检查用户是否在/etc/vsftpd/user_list\n验证SELinux状态：getenforce\n\n3. 文件传输失败# 查看vsftpd日志tail -f /var/log/vsftpd.log# 检查目录权限ls -ld /var/ftp/ftpuser\n\n五、总结FTP服务器的核心价值：✅ 标准化文件传输：跨平台文件交换通用方案✅ 简单易用：客户端支持广泛（命令行&#x2F;GUI）✅ 灵活配置：支持匿名&#x2F;认证、主动&#x2F;被动模式✅ 资源占用低：适合大文件传输场景\nvsftpd在CentOS7上的优势：🔒 安全性高：历史安全漏洞少⚙️ 配置简洁：主配置文件单一（/etc/vsftpd/vsftpd.conf）🚀 性能优异：轻量级设计，资源消耗低\n\n部署建议：\n\n生产环境务必启用FTPS加密\n为每个用户创建独立账户\n定期审查传输日志\n使用ftpusers文件禁用系统账户\n考虑替代方案（如SFTP）处理敏感数据\n\n\n\n","categories":["Linux"],"tags":["ftp"]},{"title":"Swift介绍与简单实战","url":"/2023/04/21/23.Swift/","content":"前言我这里是macOS Catalina（10.15），如果是macOS 11（big sur） 和 macOS 12（Monterey）也适用。老版本的macOS有些不被支持，请查阅相关文档一、Swift 语言简介Swift 是 Apple 于 2014 年推出的现代编程语言，用于开发 iOS、macOS、watchOS 和 tvOS 应用。它结合了 C 的性能和脚本语言的易用性，旨在替代 Objective-C。\n核心特性：\n安全设计：可选类型（Optionals）避免空指针异常\n高性能：LLVM 编译器优化，接近 C++ 的运行速度\n易读语法：类型推断、简洁闭包、字符串插值\n交互式开发：Playground 实时代码预览\n内存管理：自动引用计数（ARC）简化内存管理\n跨平台：支持 Linux&#x2F;Windows，服务端开发\n\n版本演进：\n\n\n版本\n年份\n重要特性\n\n\n\nSwift 1.0\n2014\n初始发布\n\n\nSwift 2.0\n2015\n错误处理（do-try-catch）\n\n\nSwift 4.0\n2017\nCodable 协议\n\n\nSwift 5.0\n2019\nABI 稳定性\n\n\nSwift 5.9\n2023\n宏（Macros）支持\n\n\n\n二、macOS 开发环境配置1. 安装 Xcode\n打开 App Store\n搜索 “Xcode”\n点击”获取” → “安装”（约 10GB 空间）\n安装后启动，接受许可协议\n\n2. 验证安装# 终端检查swift --version# 应输出：Apple Swift version 5.x.x\n\n3. 创建 Swift Playground（可选）\n打开 Xcode → File → New → Playground\n选择 “macOS” → “Blank”\n输入测试代码：\n\nimport Foundationprint(&quot;Hello, Swift!&quot;)\n\n三、计算器开发实战1. 创建新项目\nXcode → File → New → Project\n选择 macOS → App → Next\n输入产品名：SimpleCalculator\n语言选择 Swift，界面选择 SwiftUI\n\n2. 界面设计（SwiftUI）修改 ContentView.swift：\nimport SwiftUIstruct CalculatorButton: View &#123;    var title: String    var action: () -&gt; Void        var body: some View &#123;        Button(action: action) &#123;            Text(title)                .font(.title)                .frame(width: 60, height: 60)                .background(Color.gray.opacity(0.2))                .cornerRadius(30)        &#125;        .buttonStyle(PlainButtonStyle())    &#125;&#125;struct ContentView: View &#123;    @State private var display = &quot;0&quot;    @State private var currentNumber: Double = 0    @State private var previousNumber: Double = 0    @State private var operation: String? = nil        let buttons = [        [&quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;÷&quot;],        [&quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;×&quot;],        [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;-&quot;],        [&quot;0&quot;, &quot;.&quot;, &quot;=&quot;, &quot;+&quot;]    ]        var body: some View &#123;        VStack(spacing: 20) &#123;            // 显示区域            Text(display)                .font(.system(size: 48))                .frame(maxWidth: .infinity, alignment: .trailing)                .padding(.horizontal)                        // 按钮网格            ForEach(buttons, id: \\.self) &#123; row in                HStack(spacing: 20) &#123;                    ForEach(row, id: \\.self) &#123; button in                        CalculatorButton(title: button) &#123;                            buttonTapped(button)                        &#125;                    &#125;                &#125;            &#125;        &#125;        .frame(width: 300, height: 400)    &#125;        // 按钮处理逻辑    func buttonTapped(_ button: String) &#123;        switch button &#123;        case &quot;0&quot;...&quot;9&quot;:            if display == &quot;0&quot; &#123;                display = button            &#125; else &#123;                display += button            &#125;            currentNumber = Double(display) ?? 0                    case &quot;.&quot;:            if !display.contains(&quot;.&quot;) &#123;                display += &quot;.&quot;            &#125;                    case &quot;+&quot;, &quot;-&quot;, &quot;×&quot;, &quot;÷&quot;:            previousNumber = currentNumber            operation = button            display = &quot;0&quot;                    case &quot;=&quot;:            if let op = operation &#123;                switch op &#123;                case &quot;+&quot;: currentNumber = previousNumber + currentNumber                case &quot;-&quot;: currentNumber = previousNumber - currentNumber                case &quot;×&quot;: currentNumber = previousNumber * currentNumber                case &quot;÷&quot;: currentNumber = previousNumber / currentNumber                default: break                &#125;                display = String(format: &quot;%g&quot;, currentNumber)                operation = nil            &#125;                    default:            break        &#125;    &#125;&#125;\n\n3. 添加清除功能在 ContentView 结构内添加：\n// 在按钮网格前添加清除按钮HStack &#123;    CalculatorButton(title: &quot;C&quot;) &#123;        display = &quot;0&quot;        currentNumber = 0        previousNumber = 0        operation = nil    &#125;&#125;\n4. 运行效果\n1. 点击 **▶** 按钮运行\n2. 将显示带网格按钮的计算器界面\n3. 支持连续计算：`5 + 3 = 8 → × 2 = 16`\n\n\n四、项目优化与调试1. 界面美化// 修改按钮样式.background(buttonColor(title)).foregroundColor(buttonTextColor(title))// 添加颜色函数func buttonColor(_ title: String) -&gt; Color &#123;    if [&quot;+&quot;, &quot;-&quot;, &quot;×&quot;, &quot;÷&quot;, &quot;=&quot;].contains(title) &#123;        return .orange    &#125;    return Color.gray.opacity(0.2)&#125;func buttonTextColor(_ title: String) -&gt; Color &#123;    return [&quot;+&quot;, &quot;-&quot;, &quot;×&quot;, &quot;÷&quot;, &quot;=&quot;].contains(title) ? .white : .primary&#125;\n2. 调试技巧\n实时预览：Canvas 面板（⌥⌘↩ 打开）\n控制台输出：⌘⇧C 查看调试信息\n断点调试：在代码行号旁点击添加断点\n\n3. 项目打包\n菜单：Product → Archive\n选择 “Distribute App”\n导出为 “macOS App” 或安装包\n\n\n五、总结Swift 语言核心优势：✅ 开发效率：简洁语法减少 40% 代码量（相比 Objective-C）✅ 内存安全：可选类型和 ARC 防止常见内存错误✅ 现代特性：协议扩展、元组、模式匹配✅ 生态系统：与 Apple 平台深度集成\nSwiftUI 框架亮点：\n声明式语法：UI &#x3D; f(state)\n实时预览：所见即所得开发\n跨 Apple 平台：相同代码适配 iOS&#x2F;macOS&#x2F;watchOS\n响应式设计：自动状态更新\n\n\n学习路径建议：\n\n掌握基础语法：变量&#x2F;函数&#x2F;控制流\n理解可选类型和错误处理\n学习 SwiftUI 数据流（@State&#x2F;@Binding）\n实践 Combine 框架响应式编程\n探索 Swift 服务端开发（Vapor 框架）\n\n\n","categories":["Program Language"],"tags":["Coding"]},{"title":"QT介绍与简单实战","url":"/2023/03/13/22.QT/","content":"前言这里只是简单介绍QT以及使用QT写一个简单的计算器\n\n一、Qt 框架简介Qt 是一个跨平台的 C++ 应用程序开发框架，由挪威公司 Trolltech（现为 The Qt Company）开发。它不仅包含丰富的 GUI 组件库，还提供网络、数据库、多媒体等全栈解决方案。\n核心特点：\n跨平台支持：一次编写，编译部署到 Windows&#x2F;macOS&#x2F;Linux&#x2F;Android&#x2F;iOS\n双授权模式：商业授权（闭源）和 LGPL&#x2F;GPL 开源授权\n多语言绑定：支持 Python（PyQt&#x2F;PySide）、Rust 等语言\n现代化架构：信号槽机制、元对象系统（MOC）\n丰富模块：\nQt Widgets：传统桌面UI组件\nQt Quick：声明式UI（QML）用于现代界面\nQt Network：网络通信\nQt SQL：数据库集成\n\n\n\n应用场景：\n工业控制软件（如汽车ECU）\n医疗设备界面\n嵌入式系统\n跨平台桌面应用（如 WPS、VirtualBox）\n\n\n二、Qt 安装指南1. Windows&#x2F;macOS 安装\n访问 Qt 官网\n下载 Qt Online Installer\n运行安装程序：\n选择组件：\nQt Creator（IDE）\nQt 6.x（最新稳定版）\nMinGW&#x2F;MSVC（Windows编译工具链）\nQt Charts（可选，图表模块）\n\n\n设置安装路径（建议C盘外）\n\n\n\n2. Linux 安装（Ubuntu&#x2F;Debian）sudo apt updatesudo apt install qtcreator qt6-base-dev qt6-tools-dev# 验证安装qmake --version\n\n3. 环境验证\n启动 Qt Creator\n创建示例项目：文件 → 新建项目 → Application → Qt Widgets Application\n编译运行（Ctrl+R）显示空白窗口即成功\n\n\n三、计算器开发实战1. 创建项目\n文件 → 新建项目 → Qt Widgets Application\n命名：SimpleCalculator\n选择基类：QWidget（取消创建UI文件）\n\n2. 界面设计（代码实现）修改 mainwindow.cpp：\n#include &quot;mainwindow.h&quot;#include &lt;QGridLayout&gt;#include &lt;QPushButton&gt;#include &lt;QLineEdit&gt;MainWindow::MainWindow(QWidget *parent)    : QWidget(parent)&#123;    // 创建显示框    display = new QLineEdit(this);    display-&gt;setReadOnly(true);    display-&gt;setAlignment(Qt::AlignRight);    display-&gt;setMaxLength(15);    // 按钮文本    const QString btnTexts[16] = &#123;        &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;/&quot;,        &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;*&quot;,        &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;-&quot;,        &quot;0&quot;, &quot;.&quot;, &quot;=&quot;, &quot;+&quot;    &#125;;    // 网格布局    QGridLayout *grid = new QGridLayout;    grid-&gt;addWidget(display, 0, 0, 1, 4);    // 创建按钮    for (int i = 0; i &lt; 16; ++i) &#123;        QPushButton *btn = new QPushButton(btnTexts[i]);        connect(btn, &amp;QPushButton::clicked, this, &amp;MainWindow::onButtonClicked);        grid-&gt;addWidget(btn, 1 + i/4, i%4);    &#125;    setLayout(grid);    setWindowTitle(&quot;简易计算器&quot;);&#125;\n\n3. 计算逻辑实现在 mainwindow.h 添加：\nprivate slots:    void onButtonClicked();    private:    QLineEdit *display;    QString currentInput;    double result;    char lastOperator;\n\n在 mainwindow.cpp 添加：\nvoid MainWindow::onButtonClicked() &#123;    QPushButton *clickedButton = qobject_cast&lt;QPushButton*&gt;(sender());    QString value = clickedButton-&gt;text();        if (value &gt;= &quot;0&quot; &amp;&amp; value &lt;= &quot;9&quot; || value == &quot;.&quot;) &#123;        currentInput += value;        display-&gt;setText(currentInput);    &#125;    else if (value == &quot;=&quot;) &#123;        calculateResult();    &#125;    else &#123; // + - * /        if (!currentInput.isEmpty()) &#123;            calculateResult();        &#125;        lastOperator = value.at(0).toLatin1();        result = currentInput.toDouble();        currentInput.clear();    &#125;&#125;void MainWindow::calculateResult() &#123;    double inputNum = currentInput.toDouble();    switch (lastOperator) &#123;    case &#x27;+&#x27;: result += inputNum; break;    case &#x27;-&#x27;: result -= inputNum; break;    case &#x27;*&#x27;: result *= inputNum; break;    case &#x27;/&#x27;:         if (inputNum != 0) result /= inputNum;        else display-&gt;setText(&quot;Error&quot;);        break;    &#125;    currentInput = QString::number(result);    display-&gt;setText(currentInput);&#125;\n\n4. 运行效果[ 显示区域 ][7][8][9][/][4][5][6][*][1][2][3][-][0][.][=][+]\n\n四、项目编译与部署1. 编译运行\n点击左下角 ▶ 按钮（或 Ctrl+R）\n自动生成构建目录并启动程序\n\n2. 发布应用（Windows示例）\n构建模式选择 Release\n编译后进入 build-release 目录\n使用 windeployqt 打包：windeployqt SimpleCalculator.exe\n将生成的文件夹压缩分发\n\n\n五、总结Qt 框架核心优势：✅ 真正的跨平台：同一代码库支持桌面&#x2F;移动&#x2F;嵌入式✅ 高性能渲染：OpenGL&#x2F;Vulkan加速的现代图形栈✅ 生产力工具：Qt Designer可视化布局 + QML热重载✅ 企业级支持：商业项目可购买官方技术支持\n计算器项目关键技术点：\n信号槽机制：实现按钮点击与逻辑的解耦\n布局管理：QGridLayout自动排列控件\n类型转换：QString与数值类型的转换\n面向对象设计：利用C++特性构建组件\n\n\n学习路径建议：\n\n掌握基础Widgets组件（QPushButton&#x2F;QLabel&#x2F;QLineEdit）\n理解布局管理器（QVBoxLayout&#x2F;QHBoxLayout&#x2F;QGridLayout）\n精通信号槽通信机制\n学习Qt Creator调试技巧\n进阶探索QML现代UI开发\n\n\n\n","categories":["Program Language"],"tags":["Framework"]},{"title":"认识Spring框架","url":"/2023/05/21/24.Spring/","content":"前言这里只是简单介绍Spring框架全家桶\n\n一、Spring 框架概述Spring Framework 是由 Pivotal 团队（现为 VMware 旗下）开发的开源 Java 企业级应用框架。自 2003 年发布以来，已成为 Java EE 开发的事实标准，其核心思想是 “依赖注入” 和 “面向切面编程”。\n核心优势：\n轻量级：非侵入式设计，POJO 编程模型\n模块化：自由组合所需功能模块\n一站式：覆盖 Web 开发、数据访问、安全等全栈能力\n生态强大：丰富的扩展项目和社区支持\n\n\n二、Spring 核心项目详解1. Spring Framework基础框架，包含核心容器、AOP、数据访问等模块：\ngraph LRA[Spring Core] --&gt; B[DI/IoC]C[Spring AOP] --&gt; D[事务管理]E[Spring MVC] --&gt; F[Web开发]G[Spring JDBC] --&gt; H[数据访问]\n\n2. Spring Boot快速开发脚手架（2014年发布）：\n\n✅ 自动配置：@SpringBootApplication\n✅ 内嵌服务器：Tomcat&#x2F;Jetty\n✅ Starter 依赖：简化 Maven&#x2F;Gradle 配置\n✅ Actuator：应用监控端点\n\n// 典型启动类@SpringBootApplicationpublic class App &#123;    public static void main(String[] args) &#123;        SpringApplication.run(App.class, args);    &#125;&#125;\n\n3. Spring Data统一数据访问层：\n\n\n\n模块\n数据源\n核心接口\n\n\n\nSpring Data JPA\n关系型数据库\nJpaRepository\n\n\nSpring Data MongoDB\nNoSQL\nMongoRepository\n\n\nSpring Data Redis\n缓存\nRedisTemplate\n\n\n4. Spring Security安全解决方案：\n\n认证（Authentication）：OAuth2&#x2F;JWT&#x2F;LDAP\n授权（Authorization）：RBAC 权限控制\n防护：CSRF&#x2F;XSS&#x2F;会话固定攻击\n\n@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    protected void configure(HttpSecurity http) throws Exception &#123;        http.authorizeRequests()            .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)            .anyRequest().authenticated();    &#125;&#125;\n\n5. Spring Cloud微服务架构套件：\n\n\n\n组件\n功能\n\n\n\nEureka&#x2F;Zookeeper\n服务注册与发现\n\n\nRibbon&#x2F;Feign\n客户端负载均衡\n\n\nHystrix\n服务熔断降级\n\n\nZuul&#x2F;Gateway\nAPI 网关\n\n\nConfig\n分布式配置中心\n\n\n6. 其他关键组件\n\n\n项目\n用途\n\n\n\nSpring Batch\n批处理框架\n\n\nSpring Integration\n企业集成模式实现\n\n\nSpring Session\n分布式会话管理\n\n\nSpring GraphQL\nGraphQL 服务支持\n\n\nSpring AMQP\n消息队列集成（RabbitMQ）\n\n\n\n三、Spring 技术栈全景图graph TD    A[Spring Framework] --&gt; B[Spring Boot]    A --&gt; C[Spring Data]    A --&gt; D[Spring Security]    A --&gt; E[Spring Cloud]        B --&gt; F[快速应用开发]    C --&gt; G[统一数据访问]    D --&gt; H[安全防护]    E --&gt; I[微服务架构]        F --&gt; J[REST API]    G --&gt; K[SQL/NoSQL]    H --&gt; L[OAuth2/JWT]    I --&gt; M[服务网格]\n\n\n四、Spring 生态演进技术发展路线：\nSpring 1.x (2003)：Bean 容器和 XML 配置\nSpring 2.x (2006)：注解驱动开发\nSpring 3.x (2009)：全面支持 Java 注解\nSpring 4.x (2013)：Java 8 支持\nSpring 5.x (2017)：响应式编程（WebFlux）\nSpring 6.x (2022)：Jakarta EE 10+ 支持\n\n最新技术趋势：\n响应式编程：Project Reactor 集成\nGraalVM 原生镜像：Spring Native 支持\n云原生优化：Spring Cloud Kubernetes\n函数式编程：Spring Cloud Function\n\n\n五、总结Spring 全家桶核心价值：✅ 开发效率：Spring Boot 的约定优于配置✅ 架构统一：一致的编程模型贯穿所有组件✅ 云原生就绪：无缝迁移到 Kubernetes 环境✅ 企业级支持：商业版 VMware Tanzu 提供生产保障\n典型应用场景：\n\n\n场景\n技术组合\n\n\n\n单体应用\nBoot + MVC + Data JPA\n\n\n微服务架构\nCloud + Config + Gateway\n\n\n批处理系统\nBatch + Task\n\n\n响应式应用\nWebFlux + Reactive MongoDB\n\n\n安全敏感系统\nSecurity + OAuth2 Resource Server\n\n\n\n","categories":["Program Language"],"tags":["Framework"]},{"title":"认识go语言","url":"/2023/06/12/25.go/","content":"前言这里只是简单介绍Go语言以及写一个go语言的测试程序\n\n一、Go 语言简介Go（又称 Golang）是由 Google 开发的开源编程语言，于 2009 年正式发布。它结合了现代语言的开发效率和系统级语言的性能，特别适合构建高并发、分布式系统。\n核心特性：\n高效编译：静态编译成单一可执行文件，无外部依赖\n内置并发：goroutine 轻量级线程 + channel 通信机制\n内存安全：自动垃圾回收（GC）机制\n简洁语法：无类&#x2F;继承，通过接口实现多态\n标准库强大：覆盖网络、加密、压缩等常用功能\n跨平台支持：Windows&#x2F;Linux&#x2F;macOS&#x2F;ARM 等\n\n应用场景：\n云原生应用（Docker&#x2F;Kubernetes 均用 Go 开发）\n微服务和高并发后端服务\n命令行工具（如 Terraform）\n网络服务器和代理\n区块链应用开发\n\n\n二、Windows 平台环境配置1. 安装 Go\n访问 Go 官网\n下载 Windows 安装包（如 go1.21.0.windows-amd64.msi）\n双击运行安装程序，使用默认设置（安装到 C:\\Go）\n\n2. 配置环境变量安装程序会自动设置：\n\nGOROOT：Go 安装目录（C:\\Go）\nPATH：添加 C:\\Go\\bin\n\n验证安装：\n&gt; go version\n\n3. 配置工作空间（可选）\n创建项目目录（如 D:\\go-projects）\n设置 GOPATH：\n\n&gt; setx GOPATH &quot;D:\\go-projects&quot;\n\n在目录内创建子文件夹：\nsrc：源代码\nbin：可执行文件\npkg：编译包\n\n\n\n4. 配置代理（加速依赖下载）&gt; go env -w GO111MODULE=on&gt; go env -w GOPROXY=https://goproxy.cn,direct\n\n\n三、第一个 Go 程序1. 创建程序文件\n新建文件 hello.go（路径随意）\n输入以下代码：\n\npackage main  // 声明主包import (    &quot;fmt&quot;     // 导入格式化I/O包    &quot;time&quot;    // 导入时间包)func main() &#123;    // 打印欢迎信息    fmt.Println(&quot;=== Go语言初体验 ===&quot;)        // 获取当前时间    now := time.Now()    fmt.Printf(&quot;当前时间: %s\\n&quot;, now.Format(&quot;2006-01-02 15:04:05&quot;))        // 并发示例    go printNumbers()  // 启动goroutine        // 主程序等待    time.Sleep(1 * time.Second)    fmt.Println(&quot;\\n程序结束！&quot;)&#125;func printNumbers() &#123;    for i := 1; i &lt;= 5; i++ &#123;        fmt.Printf(&quot;%d &quot;, i)        time.Sleep(200 * time.Millisecond)    &#125;&#125;\n\n2. 运行程序&gt; go run hello.go\n输出结果：\n=== Go语言初体验 ===当前时间: 2023-08-15 14:30:221 2 3 4 5 程序结束！\n\n3. 编译可执行文件&gt; go build hello.go&gt; .\\hello.exe\n\n\n四、开发环境建议1. IDE 推荐\nVS Code：轻量级 + Go 扩展\n安装 VS Code\n添加 Go 扩展：搜索安装 golang.go\n\n\nGoLand：专业 IDE（付费）\n\n2. 常用命令\n\n\n命令\n功能\n\n\n\ngo run\n直接运行程序\n\n\ngo build\n编译可执行文件\n\n\ngo test\n运行单元测试\n\n\ngo get\n下载依赖包\n\n\ngo fmt\n格式化代码\n\n\n\n五、总结Go 语言核心优势：✅ 性能卓越：编译型语言，执行效率接近 C&#x2F;C++✅ 并发模型：goroutine 比线程轻量 100 倍✅ 部署简单：生成单一可执行文件，无运行时依赖✅ 开发高效：简洁语法 + 自动格式化 + 丰富工具链\nWindows 开发体验：\n安装便捷：MSI 安装包一键配置\n开发友好：VS Code 提供完整 Go 支持\n跨平台编译：可在 Windows 编译 Linux 程序&gt; set GOOS=linux&gt; set GOARCH=amd64&gt; go build hello.go\n\n\n","categories":["Program Language"],"tags":["Coding"]},{"title":"二周年 - 特别篇","url":"/2023/06/06/26.years2/","content":"【我的小窝两岁了】从敲下第一行 hexo init 到如今，这个用Markdown砌成的小站已晃过730天。比起第一年的“折腾狂喜”，第二年更像一场与自己的温柔对谈—。\n现在我重读旧稿——看两年前笨拙的代码注释，读去年写的一些文章，发现那些当时觉得“不够好”的文字，如今都带着鲜活的热气。Hexo没变，依然是那个安静的框架；变的是我终于懂了：比起“搭建完美博客”，更重要的是让这里成为“不想逃离的栖息地”。\n两周年快乐，我的小站。愿下一个730天，继续在静态的代码里，凿出属于自己的、流动的光\n\n","categories":["特别篇"],"tags":["Anniversary"]},{"title":"Git手册","url":"/2023/07/10/27.git/","content":"前言这里只是简单介绍git以及git的命令\n\nGit 简介Git 是一个分布式版本控制系统，由 Linus Torvalds 开发，用于高效管理项目代码的变更历史。核心特点：\n\n分布式架构：每个开发者拥有完整的仓库副本\n版本追踪：记录每次代码变更\n分支管理：轻松创建&#x2F;切换分支\n协作支持：多人协作开发解决方案\n\n\n安装与配置安装 Git\nWindows: git-scm.com&#x2F;download&#x2F;win\nmacOS: brew install git\nLinux: sudo apt install git\n\n基础配置# 设置用户信息git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;your@email.com&quot;# 查看配置git config --list# 设置默认编辑器（可选）git config --global core.editor &quot;code --wait&quot;\n\n基础工作流程创建仓库# 初始化新仓库git init # 克隆现有仓库git clone https://github.com/user/repo.git\n\n基本操作# 检查当前状态git status# 添加文件到暂存区git add filename.txt    # 添加单个文件git add .               # 添加所有修改# 提交变更到本地仓库git commit -m &quot;描述性提交信息&quot;# 查看提交历史git loggit log --oneline       # 简洁版日志\n\n分支管理# 创建新分支git branch new-feature# 切换分支git checkout new-feature# 或（新版本推荐）git switch new-feature# 创建并切换分支git checkout -b hotfix# 合并分支到当前分支git merge hotfix# 删除分支git branch -d hotfix\n\n分支策略建议main (稳定版)└── develop (开发主线)    ├── feature/login (功能分支)    └── hotfix/header-error (紧急修复)\n\n远程仓库常用操作# 添加远程仓库git remote add origin https://github.com/user/repo.git# 推送到远程仓库git push -u origin main      # 首次推送git push                     # 后续推送# 拉取远程更新git pull origin main# 获取远程更新（不自动合并）git fetch origin\n\n协作流程\n从远程仓库克隆项目：git clone\n创建功能分支：git checkout -b new-feature\n开发并提交变更\n推送分支到远程：git push -u origin new-feature\n在 GitHub&#x2F;GitLab 创建 Pull Request\n代码审查后合并到主分支\n\n\n高级操作撤销更改# 撤销工作区修改git checkout -- filename.txt# 撤销暂存区的添加git reset HEAD filename.txt# 修改最后一次提交git commit --amend\n\n解决冲突当合并出现冲突时：\n\n打开冲突文件（标记有 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;）\n手动修改保留需要的代码\n标记冲突已解决：\n\ngit add resolved-file.txtgit commit -m &quot;解决合并冲突&quot;\n\n标签管理# 创建标签git tag v1.0.0# 查看所有标签git tag# 推送标签到远程git push origin v1.0.0\n\n.gitignore 文件在项目根目录创建.gitignore文件，排除不需要版本控制的文件：\n# 示例*.lognode_modules/.DS_Storebuild/.env\n\n总结Git 核心概念\n\n\n概念\n说明\n常用命令\n\n\n\n仓库 (Repo)\n代码存储库\ngit init, git clone\n\n\n暂存区 (Stage)\n准备提交的变更区域\ngit add\n\n\n提交 (Commit)\n保存代码快照\ngit commit\n\n\n分支 (Branch)\n独立开发线\ngit branch, git switch\n\n\n远程 (Remote)\n云端代码仓库\ngit remote, git push\n\n\n最佳实践建议\n频繁提交：小步提交，保持提交原子性\n规范消息：使用清晰的提交信息（推荐Conventional Commits）\n分支策略：采用 Git Flow 或类似工作流\n定期同步：每天开始工作前 git pull\n及时解决冲突：避免长期存在的合并冲突\n保护主分支：通过 Pull Request 合并代码\n\n学习路径graph LRA[基础命令] --&gt; B[分支管理]B --&gt; C[远程协作]C --&gt; D[高级操作]D --&gt; E[工作流设计]\n\n掌握 Git 需要理论和实践结合，建议：\n\n在本地创建练习仓库\n使用 GitHub&#x2F;GitLab 创建远程仓库\n尝试各种分支操作和合并场景\n遇到问题时善用 git help &lt;command&gt;\n\n\n推荐资源：\n\n官方文档：git-scm.com&#x2F;doc\n可视化学习：learngitbranching.js.org\n备忘单：Git Cheat Sheet\n\n\n\n","categories":["Tools"],"tags":["tool"]},{"title":"开启新的征途 - 毕业特别篇","url":"/2023/06/30/26.%E6%AF%95%E4%B8%9A/","content":"\n亲爱的我：\n展信安。此刻暮色正温柔地漫过图书馆的玻璃幕墙，指尖摩挲着即将盖上钢印的毕业证书，忽然惊觉，这方承载着无数晨昏的校园，即将化作后视镜里的风景。当代码的字符与玉兰的花瓣一同飘落，我终于懂得，所谓成长，原是时光写给青春最动人的情书。\n记得初遇云计算专业时，那些如星河般璀璨的术语曾让我目眩神迷。第一次调试失败时颤抖的指尖，第一次独立完成项目时跃动的心跳，此刻都成了时光宝盒里的珍珠。感谢每一个与代码较劲的深夜，算法的逻辑如同精密的齿轮，悄然重塑着我的思维；感激每一场激烈的小组讨论，不同的见解在碰撞中迸发火花，教会我协作与包容的智慧。那些在实验室度过的漫长时光，仪器的嗡鸣与窗外的蝉鸣交织，原来早已谱写成属于我们的青春协奏曲。\n最想感谢的，是生命中那些温暖的引路人。老师们将晦涩的专业知识化作春风细雨，在答疑时不厌其烦的讲解，在迷茫时给予的鼓励，如同黑夜里的灯塔，指引我穿越知识的迷雾。还有并肩前行的同窗，我们曾在图书馆闭馆后借着路灯讨论课题，在樱花纷飞的小径分享理想与困惑。那些互相借阅的笔记、彼此打气的拥抱，都成了岁月馈赠的珍贵礼物。校园里的每一寸土地，都浸润着成长的印记——教室前排认真听讲的身影，操场上挥洒的汗水，社团活动中绽放的笑颜，共同编织成青春最绚丽的锦缎。\n站在人生新的渡口，对未来的憧憬如晨雾中的朝阳般渐渐清晰。云计算的世界正以磅礴之势改变着时代，那些曾在课堂上学习的虚拟化技术、分布式架构，此刻都化作探索未来的密钥。我期待着将大学所学融入实际工作，在数据的海洋中扬帆，用代码搭建通向未来的桥梁。或许前方会有技术迭代的挑战，会有创新路上的荆棘，但我深知，大学赋予我的不仅是专业知识，更是直面困难的勇气与持续学习的热忱。\n亲爱的我，愿你永远记得初入校园时眼中的星光，保持对技术的敬畏与热爱。在未来的征程中，既要脚踏实地深耕专业，也要仰望星空永葆好奇。愿你在追逐梦想的道路上，既能在深夜的代码世界里执着探索，也别忘了抬头看看璀璨的星河；愿你在收获成功时保持谦逊，在遭遇挫折时心怀希望。请永远相信，那些在校园里积淀的每一分努力，都将成为照亮前路的光。\n纸短情长，言不尽意。愿此去星辰大海，归来仍是那个眼中有光、心中有梦的少年。\n永远与你同行的\n另一个我\n2023.6.30\n\n","categories":["特别篇"],"tags":["毕业"]},{"title":"yaml手册","url":"/2023/08/13/28.yaml/","content":"前言这里只是简单介绍ymal语言\n\nYAML 简介YAML（YAML Ain’t Markup Language）是一种人性化的数据序列化格式，专为配置文件和数据结构交换而设计。其核心目标是：\n\n易于人类阅读和编写\n表达能力强\n支持跨语言数据交换\n与编程语言原生数据结构兼容\n\nYAML 文件扩展名通常为 .yaml 或 .yml，广泛应用于 Docker Compose、Kubernetes、Ansible、CI&#x2F;CD 配置等领域。\n\n核心特性\n简洁性：使用缩进表示层级，避免了大括号等符号\n可读性：类似自然语言的表达方式\n扩展性：支持复杂数据类型和引用\n语言无关：几乎所有编程语言都有解析库\n兼容性：可包含 JSON 文档\n\n\n基本语法# 注释以 # 开头key: value  # 键值对使用冒号分隔# 字符串通常不需要引号name: John Doe# 多行字符串description: |  This is a multi-line  string that preserves  line breaks# 折叠多行字符串summary: &gt;  This will be folded   into a single paragraph\n\n重要规则：\n\n使用 空格缩进（禁止使用制表符 Tab）\n缩进表示层级关系\n大小写敏感\n文档开头可用 ---，结尾可用 ...（可选）\n\n\n数据结构1. 标量（Scalars）基本数据类型：\nstring: &quot;Hello World&quot;  # 字符串integer: 42            # 整数float: 3.14            # 浮点数boolean: true          # 布尔值null_value: null       # 空值date: 2023-10-05       # 日期\n\n2. 序列（Sequences&#x2F;列表）# 块样式fruits:  - Apple  - Banana  - Orange# 行内样式colors: [red, green, blue]\n\n3. 映射（Mappings&#x2F;字典）# 块样式person:  name: Alice  age: 30  is_student: false# 行内样式coordinates: &#123; x: 12.5, y: -7.2 &#125;\n\n4. 复合结构employees:  - id: 001    name: Bob    skills:      - Python      - Docker  - id: 002    name: Carol    skills: [Java, Kubernetes]\n\n高级特性1. 多文档支持---# 文档1name: Document 1...---# 文档2name: Document 2\n\n2. 锚点与别名（避免重复）defaults: &amp;base_config  api_version: v1  timeout: 30sdevelopment:  &lt;&lt;: *base_config  # 合并锚点内容  debug: trueproduction:  &lt;&lt;: *base_config  debug: false\n\n3. 类型转换# 强制类型转换string_int: !!str 42float_number: !!float &quot;3.14&quot;\n\n4. 复杂键# 使用问号表示复杂键? [name, age]: value\n\n使用场景\n配置文件：应用配置（如 Docker Compose, Kubernetes YAML）\n基础设施即代码：Ansible Playbooks, Terraform\nAPI规范：OpenAPI&#x2F;Swagger\n数据序列化：替代 XML&#x2F;JSON 用于数据传输\n测试数据：结构化测试用例\n持续集成：GitHub Actions, GitLab CI\n\n\n注意事项\n缩进敏感：必须使用空格（建议2或4空格）\n避免Tab：YAML 规范禁止使用制表符\n引号使用：\n包含特殊字符时需加引号：key: &quot;value: with colon&quot;\n单引号不转义，双引号支持转义\n\n\n键唯一性：同一层级键名必须唯一\n安全限制：解析外部 YAML 时注意安全风险（如 YAML 炸弹）\n\n\n总结YAML 核心优势✅ 人类友好：相比 JSON&#x2F;XML 更易读写✅ 表达力强：支持复杂结构和引用✅ 广泛支持：几乎所有编程语言都有解析库✅ 配置首选：现代 DevOps 工具链的标准配置格式\n使用建议\n使用 2 或 4 空格 缩进（禁用 Tab）\n简单值 省略引号，特殊字符值使用引号\n大型配置使用 锚点&#x2F;别名 减少重复\n验证 YAML 文件：# Python 验证python -c &#x27;import yaml; yaml.safe_load(open(&quot;file.yaml&quot;))&#x27;\n搭配 Schema 验证（如 JSON Schema）确保结构正确\n\n典型工作流graph LRA[编写YAML] --&gt; B[版本控制] B --&gt; C[CI/CD解析] C --&gt; D[部署执行]\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"yml与yaml","url":"/2023/09/15/29.yml/","content":"前言这里只是简单对比yaml 与 yml1. 基本概念\nYAML (YAML Ain’t Markup Language)一种人类友好的数据序列化标准，2001年由Clark Evans等人提出，扩展名为.yaml\n\nYML本质是YAML的简写文件扩展名（早期Windows系统限制扩展名长度），技术上无区别\n\n\n\n2. 发展时间线\n\n\n时间\n事件\n\n\n\n2001\nYAML 1.0规范发布，官方推荐.yaml扩展名\n\n\n2002-2004\n早期开发者因Windows 9x系统限制（仅支持3字符扩展名）开始使用.yml\n\n\n2004\nYAML 1.1发布，仍建议使用.yaml\n\n\n2009\nYAML 1.2发布，扩展名争议持续存在\n\n\n现今\n主流工具同时支持两种扩展名\n\n\n\n3. 技术对比\n\n\n维度\nYAML (.yaml)\nYML (.yml)\n\n\n\n文件识别\n官方推荐格式\n历史遗留格式\n\n\n兼容性\n所有现代工具支持\n可能存在极少数工具识别问题\n\n\n性能\n无差异（相同解析器处理）\n无差异\n\n\n规范支持\n官方文档明确推荐\n非官方约定俗成\n\n\n\n4. 典型使用场景\n.yaml 更常见于：\n\nKubernetes 配置文件\nAnsible Playbooks\nCI&#x2F;CD 配置文件（如GitLab CI）\n开源项目规范文档\n\n\n.yml 更常见于：\n\n遗留系统配置\nRuby on Rails框架配置\n早期Docker Compose文件\n\n\n\n\n5. 总结建议\n优先选择.yaml（符合官方规范，减少潜在兼容性问题）\n保持项目统一（团队&#x2F;项目内部应统一扩展名）\n历史项目处理：旧系统可保留.yml，新文件建议用.yaml\n技术本质：两者在数据存储和解析性能上完全等同\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"一个免费的域名","url":"/2021/08/13/3.Domain/","content":"前言我这里是Windows10&#x2F;11专业工作版(其他Windows版本也适用)如果你的设备是已经是结束支持的Windows7，请查阅其他相关是手册工具是Microsoft Edge，这里自动翻译为了中文关于建立个人网站，这里有有一个方式就是域名和代码托管自己做了blog，然后利用Github托管，Github Pages 的访问域名自己不太喜欢，就自己上网找了很久，本来想注册双胞胎域名，然后注册失败了这边就推荐一个永久免费的域名 eu.org 结尾，我自己也用的是这个域名，使用和注册界面确实有亿点点丑陋，免费的还要什么自行车，冲吧！\n\n什么是 eu.org 域名eu.org是欧盟组织下面的域名，EU代表欧盟，Paul Mockapetris 在1996年的9-10月份创建了这个域名的DNS服务器。计划是专门给无力承担费用的一些组织使用的。所以它对个人和组织是免费注册的。目前已经被谷歌，Cloudfare等一些大公司认可为顶级域名注册账号打开官网，点击注册eu.org官网链接点击这个连接就可以跳转到eu.org官方网站界面\n\n填写信息打开这个网站点击注册，然后填写自己的详细信息就好了(可以是虚假生成的)，等待审核通过就好审核通过了会给你发生一个邮件会告诉你申请到的账号注意：虚拟生成的身份不要填写虚拟身份中的邮箱，邮箱填写自己的，方便接收到账号 (密码是你自己定义的，认真记录保存一下)\n\n域名登录输入账号和密码登录即可，\n申请域名New Domain点击New Domain 进入域名申请界面\n设置域名名在这就可以选择一个 New Domain，就可以新建立一个自己的域名\n填写表单在填写把下面的详细信息前必须在 Complete domain name 处填写你要申请的域名全名格式为： xxx .eu.org填写完毕后就可以完成你身份的表单（信息可以是虚假的）\n添加域名解析服务注意在选择的时候要选择 sever names,可以是使用自己的DNSPod输入后点击submit，出现 没有问题就好了这样等待一段时间的就会发邮件到你的邮箱中，告诉你结果（一般是7天时间）结语接下来我会带着你将自己的域名添加到cloudfare中！！！如果曦和的文章对您有帮助，请收藏一下！！！","categories":["domain"],"tags":["Web"]},{"title":"C++语言知识点汇总","url":"/2023/11/15/31.C++/","content":"前言这里只是简单列出C++语言的知识点\n\n一、基础语法1.1 基本结构#include &lt;iostream&gt;  // 头文件包含using namespace std; // 命名空间int main() &#123;        // 主函数    cout &lt;&lt; &quot;Hello World!&quot;; // 输出    return 0;       // 返回值&#125;\n1.2 数据类型\n\n\n类型\n说明\n示例\n\n\n\nint\n整型\nint a = 10;\n\n\nfloat\n单精度浮点\nfloat b = 3.14f;\n\n\ndouble\n双精度浮点\ndouble c = 3.14159;\n\n\nchar\n字符\nchar d = &#39;A&#39;;\n\n\nbool\n布尔\nbool e = true;\n\n\nvoid\n无类型\nvoid func();\n\n\nauto\n自动推导(C++11)\nauto f = 5.0;\n\n\n1.3 变量与常量int var = 10;           // 变量const int MAX = 100;    // 常量constexpr int SIZE = 50;// 编译期常量(C++11)\n\n二、运算符2.1 算术运算符+ - * / % ++ --\n\n2.2 关系运算符== != &gt; &lt; &gt;= &lt;=\n\n2.3 逻辑运算符&amp;&amp; || !\n\n2.4 位运算符&amp; | ^ ~ &lt;&lt; &gt;&gt;\n\n2.5 赋值运算符= += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |=\n\n2.6 其他运算符sizeof() ?: :: . -&gt; &amp; * \n\n三、流程控制3.1 条件语句if (condition) &#123;    // ...&#125; else if (condition2) &#123;    // ...&#125; else &#123;    // ...&#125;switch (var) &#123;    case 1: /*...*/ break;    default: /*...*/&#125;\n\n3.2 循环结构// for循环for (int i = 0; i &lt; 10; i++) &#123; /*...*/ &#125;// while循环while (condition) &#123; /*...*/ &#125;// do-while循环do &#123; /*...*/ &#125; while (condition);// 范围for循环(C++11)for (auto&amp; item : container) &#123; /*...*/ &#125;\n\n四、函数4.1 函数定义returnType funcName(parameters) &#123;    // 函数体    return value;&#125;\n\n4.2 函数重载void print(int i) &#123; /*...*/ &#125;void print(double d) &#123; /*...*/ &#125;\n\n4.3 默认参数void func(int a, int b = 10) &#123; /*...*/ &#125;\n\n4.4 Lambda表达式(C++11)auto lambda = [](int x) -&gt; int &#123; return x * x; &#125;;\n\n五、面向对象编程5.1 类与对象class MyClass &#123;public:     // 访问修饰符    // 构造函数    MyClass() &#123; /*...*/ &#125;    // 析构函数    ~MyClass() &#123; /*...*/ &#125;        // 成员函数    void method() &#123; /*...*/ &#125;    private:    // 成员变量    int data;&#125;;\n\n5.2 继承class Base &#123; /*...*/ &#125;;class Derived : public Base &#123; /*...*/ &#125;;\n\n5.3 多态class Base &#123;public:    virtual void func() &#123; /*...*/ &#125;  // 虚函数    virtual void pure() = 0;        // 纯虚函数&#125;;\n\n六、模板与泛型编程6.1 函数模板template &lt;typename T&gt;T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;\n\n6.2 类模板template &lt;class T&gt;class Stack &#123;    // ...&#125;;\n\n6.3 可变参数模板(C++11)template&lt;typename... Args&gt;void func(Args... args) &#123; /*...*/ &#125;\n\n七、标准模板库(STL)7.1 容器vector&lt;int&gt; v = &#123;1,2,3&#125;;       // 动态数组list&lt;string&gt; lst;               // 双向链表map&lt;string, int&gt; m;             // 关联数组unordered_set&lt;int&gt; uset;        // 哈希集合(C++11)\n\n7.2 算法sort(v.begin(), v.end());       // 排序auto it = find(v.begin(), v.end(), 3); // 查找\n\n7.3 迭代器for (auto it = v.begin(); it != v.end(); ++it) &#123;    cout &lt;&lt; *it &lt;&lt; endl;&#125;\n\n八、内存管理8.1 动态内存int* p = new int(10);  // 分配delete p;               // 释放\n\n8.2 智能指针(C++11)unique_ptr&lt;int&gt; uptr(new int(5));shared_ptr&lt;int&gt; sptr = make_shared&lt;int&gt;(10);weak_ptr&lt;int&gt; wptr = sptr;\n\n九、异常处理try &#123;    throw runtime_error(&quot;Error&quot;);&#125; catch (const exception&amp; e) &#123;    cerr &lt;&lt; e.what() &lt;&lt; endl;&#125;\n\n十、文件操作#include &lt;fstream&gt;ofstream out(&quot;file.txt&quot;);out &lt;&lt; &quot;Text&quot;;out.close();\n\n十一、多线程(C++11)#include &lt;thread&gt;thread t([]()&#123; /* 任务 */ &#125;);t.join();\n\n十二、现代C++特性12.1 移动语义(C++11)string str1 = &quot;Hello&quot;;string str2 = std::move(str1);  // 移动构造\n\n12.2 类型推导(C++11&#x2F;14)auto x = 5;          // intdecltype(auto) y = x; // int\n\n12.3 结构化绑定(C++17)auto [x, y] = make_pair(1, 2.0);\n\n十三、设计模式实现13.1 单例模式class Singleton &#123;public:    static Singleton&amp; getInstance() &#123;        static Singleton instance;        return instance;    &#125;private:    Singleton() = default;&#125;;\n\n13.2 工厂模式class Product &#123;public:    virtual ~Product() &#123;&#125;    virtual void op() = 0;&#125;;class Factory &#123;public:    static unique_ptr&lt;Product&gt; create(int type);&#125;;\n\n十四、最佳实践\n使用RAII管理资源\n优先使用智能指针而非裸指针\n使用const正确性\n遵循三&#x2F;五&#x2F;零法则\n使用命名空间组织代码\n优先使用STL而非原生数组\n使用nullptr替代NULL(C++11)\n使用类型别名替代宏定义\n使用范围for循环遍历容器\n使用移动语义优化性能注：本文档涵盖了C++98到C++20的主要语法特性，实际使用时需注意编译器对特性的支持情况。\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"C语言知识点汇总","url":"/2023/10/13/30.C/","content":"前言这里只是简单列出C语言的知识点\n\n1. 基础语法1.1 数据类型int a = 10;          // 整型float b = 3.14;      // 单精度浮点double c = 3.141592; // 双精度浮点char d = &#x27;A&#x27;;        // 字符型\n\n1.2 运算符\n算术运算符：+ - * / %\n关系运算符：== != &gt; &lt; &gt;= &lt;=\n逻辑运算符：&amp;&amp; || !\n\n\n2. 流程控制2.1 条件语句if(condition) &#123;    // 代码块&#125; else if(condition2) &#123;    // 代码块&#125; else &#123;    // 代码块&#125;\n\n2.2 循环结构// for循环for(int i=0; i&lt;10; i++) &#123;    printf(&quot;%d\\n&quot;, i);&#125;// while循环while(condition) &#123;    // 代码块&#125;// do-while循环do &#123;    // 代码块&#125; while(condition);\n\n3. 函数// 函数定义int add(int a, int b) &#123;    return a + b;&#125;// 函数调用int result = add(3, 5);\n\n4. 数组与指针4.1 数组int arr[5] = &#123;1,2,3,4,5&#125;; // 一维数组int matrix[2][3] = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125;; // 二维数组\n\n4.2 指针int var = 20;int *ptr = &amp;var;  // 指针声明和赋值printf(&quot;%d&quot;, *ptr); // 解引用\n\n5. 结构体与联合体5.1 结构体struct Student &#123;    char name[20];    int age;    float score;&#125;;struct Student stu1 = &#123;&quot;Alice&quot;, 20, 90.5&#125;;\n\n5.2 联合体union Data &#123;    int i;    float f;    char str[20];&#125;;\n\n6. 文件操作FILE *fptr;fptr = fopen(&quot;file.txt&quot;, &quot;w&quot;); // 打开文件fprintf(fptr, &quot;Hello World&quot;); // 写入文件fclose(fptr);                 // 关闭文件\n\n7. 内存管理int *ptr = (int*)malloc(5*sizeof(int)); // 动态分配内存free(ptr); // 释放内存\n\n8. 预处理器#define PI 3.14159   // 宏定义#include &lt;stdio.h&gt;    // 头文件包含#ifdef DEBUG          // 条件编译    // 调试代码#endif\n\n9. 常用标准库\n&lt;stdio.h&gt;: 输入输出函数\n&lt;stdlib.h&gt;: 内存分配等通用函数\n&lt;string.h&gt;: 字符串处理函数\n&lt;math.h&gt;: 数学函数\n\n\n10. 重要特性\n面向过程编程\n直接内存访问能力\n高效的底层控制\n可移植性强\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"Java知识点汇总","url":"/2023/12/10/31.Java/","content":"前言这里只是简单列出Java语言的知识点\n\n一、基础语法1.1 程序结构// 类声明public class Main &#123;    // 主方法 - 程序入口    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World!&quot;); // 输出语句    &#125;&#125;\n\n1.2 数据类型\n\n\n类型\n说明\n示例\n\n\n\nbyte\n8位整数\nbyte b = 100;\n\n\nshort\n16位整数\nshort s = 1000;\n\n\nint\n32位整数\nint i = 100000;\n\n\nlong\n64位整数\nlong l = 100000L;\n\n\nfloat\n32位浮点\nfloat f = 3.14f;\n\n\ndouble\n64位浮点\ndouble d = 3.14159;\n\n\nchar\n16位Unicode\nchar c = &#39;A&#39;;\n\n\nboolean\n布尔值\nboolean flag = true;\n\n\nString\n字符串(类)\nString str = &quot;Java&quot;;\n\n\n1.3 变量与常量int count = 10;          // 变量final double PI = 3.14;    // 常量var list = new ArrayList&lt;String&gt;(); // 局部变量类型推断(Java 10+)\n\n二、运算符2.1 算术运算符+ - * / % ++ --\n\n2.2 关系运算符== != &gt; &lt; &gt;= &lt;=\n\n2.3 逻辑运算符&amp;&amp; || !\n\n2.4 位运算符&amp; | ^ ~ &lt;&lt; &gt;&gt; &gt;&gt;&gt;\n\n2.5 赋值运算符= += -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=\n\n2.6 三目运算符condition ? expr1 : expr2\n\n2.7 instanceof 运算符obj instanceof String\n\n三、流程控制3.1 条件语句if (condition) &#123;    // ...&#125; else if (condition2) &#123;    // ...&#125; else &#123;    // ...&#125;switch (variable) &#123;    case 1:         // ...        break;    default:        // ...&#125;\n\n3.2 循环结构// for循环for (int i = 0; i &lt; 10; i++) &#123; /*...*/ &#125;// 增强for循环for (String item : collection) &#123; /*...*/ &#125;// while循环while (condition) &#123; /*...*/ &#125;// do-while循环do &#123; /*...*/ &#125; while (condition);\n\n四、方法与函数4.1 方法定义[修饰符] 返回类型 方法名(参数列表) &#123;    // 方法体    return 返回值;&#125;\n\n4.2 方法重载void print(int i) &#123; /*...*/ &#125;void print(String s) &#123; /*...*/ &#125;\n\n4.3 可变参数void method(String... args) &#123; /*...*/ &#125;\n\n4.4 Lambda表达式(Java 8+)Function&lt;Integer, Integer&gt; square = x -&gt; x * x;\n\n五、面向对象编程5.1 类与对象public class Person &#123;    // 字段    private String name;        // 构造方法    public Person(String name) &#123;        this.name = name;    &#125;        // 方法    public String getName() &#123;        return name;    &#125;&#125;\n\n5.2 继承class Student extends Person &#123;    // ...&#125;\n\n5.3 多态interface Animal &#123;    void sound();&#125;class Dog implements Animal &#123;    public void sound() &#123; System.out.println(&quot;Woof&quot;); &#125;&#125;\n\n5.4 抽象类与接口abstract class Shape &#123;    abstract void draw();&#125;interface Drawable &#123;    void draw();&#125;\n\n六、异常处理6.1 try-catch-finallytry &#123;    // 可能抛出异常的代码&#125; catch (IOException e) &#123;    // 异常处理&#125; finally &#123;    // 最终执行的代码&#125;\n\n6.2 throws声明void readFile() throws IOException &#123; /*...*/ &#125;\n\n6.3 自定义异常class MyException extends Exception &#123;    // ...&#125;\n\n七、集合框架7.1 主要接口List&lt;String&gt; list = new ArrayList&lt;&gt;();  // 有序可重复Set&lt;Integer&gt; set = new HashSet&lt;&gt;();    // 无序唯一Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 键值对\n\n7.2 常用操作list.add(&quot;Java&quot;);          // 添加元素set.contains(5);          // 检查存在map.put(&quot;key&quot;, 10);       // 放入键值\n\n7.3 流式操作(Java 8+)list.stream()    .filter(s -&gt; s.length() &gt; 3)    .map(String::toUpperCase)    .forEach(System.out::println);\n\n八、输入输出8.1 文件读写try (BufferedReader br = new BufferedReader(new FileReader(&quot;file.txt&quot;))) &#123;    String line;    while ((line = br.readLine()) != null) &#123;        System.out.println(line);    &#125;&#125;\n\n8.2 标准I&#x2F;OScanner sc = new Scanner(System.in);String input = sc.nextLine();\n\n九、多线程9.1 线程创建// 继承Thread类class MyThread extends Thread &#123;    public void run() &#123; /*...*/ &#125;&#125;// 实现Runnable接口Runnable task = () -&gt; &#123; /*...*/ &#125;;new Thread(task).start();\n\n9.2 线程池ExecutorService executor = Executors.newFixedThreadPool(5);executor.submit(() -&gt; System.out.println(&quot;Task running&quot;));\n\n9.3 同步机制synchronized (lockObject) &#123;    // 同步代码块&#125;\n\n十、现代Java特性10.1 记录类(Java 16+)record Point(int x, int y) &#123; &#125;\n\n10.2 模式匹配(Java 17+)if (obj instanceof String s) &#123;    System.out.println(s.length());&#125;\n\n10.3 密封类(Java 17+)sealed class Shape permits Circle, Square &#123; &#125;\n\n十一、注解与反射11.1 内置注解@Override@Deprecated@SuppressWarnings(&quot;unchecked&quot;)\n\n11.2 自定义注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123;    String value() default &quot;&quot;;&#125;\n\n11.3 反射APIClass&lt;?&gt; clazz = Class.forName(&quot;java.lang.String&quot;);Method method = clazz.getMethod(&quot;length&quot;);\n\n十二、模块系统(Java 9+)12.1 模块声明module com.example.myapp &#123;    requires java.base;    exports com.example.mypackage;&#125;\n\n十三、最佳实践\n遵循命名规范(驼峰命名法)\n使用面向接口编程\n优先使用集合框架而非数组\n合理使用异常处理机制\n避免使用原始类型(优先泛型)\n使用try-with-resources管理资源\n遵循SOLID设计原则\n使用不可变对象提高线程安全性\n合理使用Optional避免NullPointerException\n保持代码可读性和可维护性 注：本文档涵盖Java 8到Java 17的主要语法特性，实际使用时需注意JDK版本支持情况。\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"python知识点汇总","url":"/2024/01/10/32.Python/","content":"前言这里只是简单列出python 3语言的知识点\n\n一、基础语法1.1 程序结构# 单行注释&quot;&quot;&quot;多行注释/文档字符串&quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;:  # 主程序入口    print(&quot;Hello World!&quot;)    # 输出语句\n\n1.2 变量与数据类型\n\n\n类型\n说明\n示例\n\n\n\nint\n整数\nnum = 10\n\n\nfloat\n浮点数\npi = 3.14\n\n\nbool\n布尔值\nflag = True\n\n\nstr\n字符串\ns = &quot;Python&quot;\n\n\nlist\n列表\nlst = [1, 2, 3]\n\n\ntuple\n元组\ntup = (1, 2, 3)\n\n\nset\n集合\ns = &#123;1, 2, 3&#125;\n\n\ndict\n字典\nd = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;\n\n\n1.3 动态类型特性var = 10        # 整数var = &quot;Python&quot;  # 字符串var = [1, 2, 3] # 列表\n\n二、运算符2.1 算术运算符+ - * / // % **\n\n2.2 比较运算符== != &gt; &lt; &gt;= &lt;=\n\n2.3 逻辑运算符and or not\n\n2.4 成员运算符in not in\n\n2.5 身份运算符is is not\n\n2.6 位运算符&amp; | ^ ~ &lt;&lt; &gt;&gt;\n\n三、流程控制3.1 条件语句if condition1:    # ...elif condition2:    # ...else:    # ...\n\n3.2 循环结构# while循环while condition:    # ...# for循环for item in sequence:    # ...# 循环控制break     # 终止循环continue  # 跳过本次迭代\n\n3.3 异常处理try:    # 可能出错的代码except ValueError as e:    # 异常处理finally:    # 最终执行\n\n四、函数4.1 函数定义def func(arg1, arg2=default):    &quot;&quot;&quot;文档字符串&quot;&quot;&quot;    # 函数体    return result\n\n4.2 参数类型# 位置参数func(a, b)# 关键字参数func(arg1=value1, arg2=value2)# 可变参数def func(*args, **kwargs):    # args是元组，kwargs是字典\n\n4.3 Lambda表达式square = lambda x: x**2\n\n4.4 装饰器def decorator(func):    def wrapper(*args, **kwargs):        # 装饰逻辑        return func(*args, **kwargs)    return wrapper@decoratordef func():    # ...\n\n五、数据结构5.1 列表操作lst = [1, 2, 3]lst.append(4)       # 添加元素lst[1:3]           # 切片[x**2 for x in lst] # 列表推导式\n\n5.2 字典操作d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;d[&#x27;c&#x27;] = 3         # 添加键值对d.get(&#x27;a&#x27;)         # 安全获取&#123;k: v for k, v in d.items() if v &gt; 1&#125; # 字典推导式\n\n5.3 集合操作s = &#123;1, 2, 3&#125;s.add(4)            # 添加元素s1 | s2             # 并集s1 &amp; s2             # 交集\n\n六、面向对象编程6.1 类与对象class MyClass:    # 类属性    class_attr = 0        def __init__(self, attr):        # 实例属性        self.attr = attr        def method(self):        # 实例方法        return self.attr\n\n6.2 继承与多态class Child(Parent):    def __init__(self, attr):        super().__init__(attr)        def method(self):        # 方法重写        return super().method() * 2\n\n6.3 特殊方法class Vector:    def __add__(self, other):  # 运算符重载        return Vector(self.x + other.x)        def __str__(self):         # 字符串表示        return f&quot;Vector(&#123;self.x&#125;)&quot;\n\n七、模块与包7.1 模块导入import modulefrom module import funcimport module as aliasfrom package.submodule import Class\n\n7.2 创建包my_package/    __init__.py    module1.py    module2.py\n\n八、文件操作8.1 文件读写with open(&#x27;file.txt&#x27;, &#x27;r&#x27;) as f:    content = f.read()with open(&#x27;file.txt&#x27;, &#x27;w&#x27;) as f:    f.write(&quot;New content&quot;)\n\n8.2 常见模式&#x27;r&#x27;   # 读取（默认）&#x27;w&#x27;   # 写入（覆盖）&#x27;a&#x27;   # 追加&#x27;r+&#x27;  # 读写&#x27;b&#x27;   # 二进制模式\n\n九、高级特性9.1 生成器def gen():    yield 1    yield 2g = gen()next(g)  # 返回1\n\n9.2 上下文管理器class MyContext:    def __enter__(self):        # 进入上下文        return self        def __exit__(self, exc_type, exc_val, exc_tb):        # 退出上下文        pass\n\n9.3 类型注解(Python 3.5+)def func(name: str, age: int) -&gt; str:    return f&quot;&#123;name&#125; is &#123;age&#125; years old&quot;\n\n十、标准库常用模块\n\n\n模块\n用途\n\n\n\nos\n操作系统接口\n\n\nsys\n系统相关参数\n\n\nmath\n数学运算\n\n\ndatetime\n日期时间\n\n\njson\nJSON处理\n\n\nre\n正则表达式\n\n\ncollections\n扩展容器\n\n\nitertools\n迭代工具\n\n\nmultiprocessing\n多进程\n\n\nthreading\n多线程\n\n\nasyncio\n异步IO\n\n\n\n十一、最佳实践\n遵循PEP 8代码风格指南\n使用虚拟环境管理依赖\n优先使用with语句管理资源\n合理使用异常处理\n编写文档字符串(docstring)\n使用列表推导式简化代码\n避免使用全局变量\n使用类型注解提高可读性\n编写单元测试保证质量\n保持代码简洁可读本文档涵盖Python 3.x主要语法特性，部分高级特性需要特定版本支持。\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"Go语言知识点汇总","url":"/2024/02/11/33.go/","content":"前言这里只是简单列出GO语言的知识点\n\n一、基础语法1.1 程序结构package main  // 包声明import &quot;fmt&quot;  // 导入语句func main() &#123; // 主函数    fmt.Println(&quot;Hello, 世界！&quot;) // 输出语句&#125;\n\n1.2 变量与常量var name string = &quot;Go&quot;  // 显式类型声明var age = 10            // 类型推断height := 1.75          // 短变量声明（函数内）const PI = 3.14         // 常量const (    StatusOK = 200    NotFound = 404)\n\n1.3 基本数据类型\n\n\n类型\n说明\n示例\n\n\n\nbool\n布尔值\ntrue, false\n\n\nstring\n字符串\n&quot;Go&quot;\n\n\nint int8-int64\n整型\n42\n\n\nuint uint8-uint64\n无符号整型\n255\n\n\nfloat32 float64\n浮点型\n3.14\n\n\ncomplex64 complex128\n复数\n1+2i\n\n\nbyte\nuint8别名\n0xFF\n\n\nrune\nint32别名(Unicode)\n&#39;中&#39;\n\n\n\n二、运算符2.1 算术运算符+ - * / % ++ --\n\n2.2 关系运算符== != &gt; &lt; &gt;= &lt;=\n\n2.3 逻辑运算符&amp;&amp; || !\n\n2.4 位运算符&amp; | ^ &amp;^ &lt;&lt; &gt;&gt;\n\n2.5 赋值运算符= += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |=\n\n2.6 其他运算符&amp;  // 取地址*  // 指针解引用&lt;- // 通道操作\n\n三、流程控制3.1 条件语句if x &gt; 0 &#123;    // ...&#125; else if x == 0 &#123;    // ...&#125; else &#123;    // ...&#125;switch os := runtime.GOOS; os &#123;case &quot;darwin&quot;:    fmt.Println(&quot;macOS&quot;)case &quot;linux&quot;:    fmt.Println(&quot;Linux&quot;)default:    fmt.Printf(&quot;%s.\\n&quot;, os)&#125;\n\n3.2 循环结构// 只有for循环for i := 0; i &lt; 10; i++ &#123;    // ...&#125;// while形式for x &lt; 100 &#123;    // ...&#125;// 无限循环for &#123;    // ...    break // 退出循环&#125;// range迭代for idx, val := range slice &#123;    // ...&#125;\n\n四、函数4.1 函数定义func add(a int, b int) int &#123;    return a + b&#125;// 多返回值func swap(x, y string) (string, string) &#123;    return y, x&#125;// 命名返回值func split(sum int) (x, y int) &#123;    x = sum * 4 / 9    y = sum - x    return // 裸返回&#125;\n\n4.2 高阶函数// 函数作为参数func compute(fn func(float64, float64) float64) float64 &#123;    return fn(3, 4)&#125;// 闭包func adder() func(int) int &#123;    sum := 0    return func(x int) int &#123;        sum += x        return sum    &#125;&#125;\n\n五、复合数据类型5.1 数组与切片var a [3]int           // 数组b := [...]int&#123;1, 2, 3&#125; // 数组自动长度推断s := []int&#123;1, 2, 3&#125;    // 切片s = append(s, 4)       // 追加元素sub := s[1:3]          // 子切片\n\n5.2 映射(Map)m := make(map[string]int)m[&quot;key&quot;] = 42delete(m, &quot;key&quot;)val, ok := m[&quot;key&quot;] // 检查存在性\n\n5.3 结构体type Vertex struct &#123;    X, Y float64&#125;v := Vertex&#123;1, 2&#125;v.X = 4p := &amp;vp.Y = 8 // 隐式解引用\n\n六、方法与接口6.1 方法// 值接收者func (v Vertex) Abs() float64 &#123;    return math.Sqrt(v.X*v.X + v.Y*v.Y)&#125;// 指针接收者func (v *Vertex) Scale(f float64) &#123;    v.X = v.X * f    v.Y = v.Y * f&#125;\n\n6.2 接口type Abser interface &#123;    Abs() float64&#125;var a Absera = Vertex&#123;3, 4&#125; // 实现接口fmt.Println(a.Abs())\n\n6.3 类型断言与类型开关var i interface&#123;&#125; = &quot;hello&quot;s := i.(string)   // 类型断言s, ok := i.(string)switch v := i.(type) &#123; // 类型开关case int:    // ...case string:    // ...default:    // ...&#125;\n\n七、并发编程7.1 Goroutinego say(&quot;world&quot;) // 启动goroutinesay(&quot;hello&quot;)\n\n7.2 Channelch := make(chan int) // 无缓冲通道buffered := make(chan int, 100) // 缓冲通道ch &lt;- 42    // 发送v := &lt;-ch   // 接收close(ch)   // 关闭通道\n\n7.3 Selectselect &#123;case msg1 := &lt;-ch1:    fmt.Println(msg1)case msg2 := &lt;-ch2:    fmt.Println(msg2)case &lt;-time.After(time.Second):    fmt.Println(&quot;timeout&quot;)default:    fmt.Println(&quot;no activity&quot;)&#125;\n\n八、错误处理8.1 错误类型func doSomething() error &#123;    return errors.New(&quot;something went wrong&quot;)&#125;if err := doSomething(); err != nil &#123;    log.Fatal(err)&#125;\n\n8.2 自定义错误type MyError struct &#123;    When time.Time    What string&#125;func (e *MyError) Error() string &#123;    return fmt.Sprintf(&quot;at %v, %s&quot;, e.When, e.What)&#125;\n\n九、标准库常用包\n\n\n包名\n用途\n\n\n\nfmt\n格式化I&#x2F;O\n\n\nos\n操作系统接口\n\n\nio\n基本I&#x2F;O接口\n\n\nbufio\n缓冲I&#x2F;O\n\n\nstrconv\n字符串转换\n\n\nstrings\n字符串操作\n\n\nbytes\n字节操作\n\n\nsort\n排序\n\n\nencoding/json\nJSON处理\n\n\nnet/http\nHTTP协议\n\n\nsync\n同步原语\n\n\ntime\n时间处理\n\n\ntesting\n测试支持\n\n\n\n十、最佳实践\n遵循Go代码风格（gofmt）\n使用短变量声明（函数内）\n错误处理而非异常\n优先组合而非继承\n使用接口解耦\n避免全局变量\n并发安全设计\n编写单元测试（go test）\n文档注释（godoc）\n保持简单和可读性注：本文档基于Go 1.18+版本，部分特性如泛型需要较新版本支持。\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"Html语言知识点汇总","url":"/2024/03/15/34.html/","content":"前言这里只是简单列出html的知识点\n\n一、基础结构1.1 文档基本结构&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 页面内容 --&gt;&lt;/body&gt;&lt;/html&gt;\n\n1.2 基本组成部分\n\n\n部分\n说明\n\n\n\n&lt;!DOCTYPE&gt;\n文档类型声明\n\n\n&lt;html&gt;\n根元素\n\n\n&lt;head&gt;\n头部（元数据）\n\n\n&lt;body&gt;\n主体内容\n\n\n\n二、常用元素2.1 文本元素&lt;h1&gt;到&lt;h6&gt;标题&lt;/h1&gt;&lt;p&gt;段落文本&lt;/p&gt;&lt;span&gt;行内文本&lt;/span&gt;&lt;br&gt;换行&lt;hr&gt;水平线&lt;strong&gt;强调文本&lt;/strong&gt;&lt;em&gt;斜体强调&lt;/em&gt;\n\n2.2 列表&lt;!-- 无序列表 --&gt;&lt;ul&gt;    &lt;li&gt;项目1&lt;/li&gt;    &lt;li&gt;项目2&lt;/li&gt;&lt;/ul&gt;&lt;!-- 有序列表 --&gt;&lt;ol&gt;    &lt;li&gt;第一项&lt;/li&gt;    &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt;&lt;!-- 定义列表 --&gt;&lt;dl&gt;    &lt;dt&gt;术语&lt;/dt&gt;    &lt;dd&gt;描述&lt;/dd&gt;&lt;/dl&gt;\n\n2.3 表格&lt;table&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;表头1&lt;/th&gt;            &lt;th&gt;表头2&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;        &lt;tr&gt;            &lt;td&gt;数据1&lt;/td&gt;            &lt;td&gt;数据2&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;\n\n三、表单元素3.1 基本表单&lt;form action=&quot;/submit&quot; method=&quot;POST&quot;&gt;    &lt;label for=&quot;name&quot;&gt;姓名：&lt;/label&gt;    &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;username&quot;&gt;        &lt;label for=&quot;pass&quot;&gt;密码：&lt;/label&gt;    &lt;input type=&quot;password&quot; id=&quot;pass&quot; name=&quot;password&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;\n\n3.2 输入类型&lt;input type=&quot;text&quot;&gt;     &lt;!-- 文本 --&gt;&lt;input type=&quot;password&quot;&gt; &lt;!-- 密码 --&gt;&lt;input type=&quot;email&quot;&gt;    &lt;!-- 邮箱 --&gt;&lt;input type=&quot;number&quot;&gt;   &lt;!-- 数字 --&gt;&lt;input type=&quot;date&quot;&gt;     &lt;!-- 日期 --&gt;&lt;input type=&quot;checkbox&quot;&gt; &lt;!-- 复选框 --&gt;&lt;input type=&quot;radio&quot;&gt;    &lt;!-- 单选按钮 --&gt;&lt;input type=&quot;file&quot;&gt;     &lt;!-- 文件上传 --&gt;&lt;input type=&quot;hidden&quot;&gt;   &lt;!-- 隐藏字段 --&gt;\n\n3.3 其他表单元素&lt;select&gt;    &lt;option value=&quot;1&quot;&gt;选项1&lt;/option&gt;    &lt;option value=&quot;2&quot;&gt;选项2&lt;/option&gt;&lt;/select&gt;&lt;textarea rows=&quot;4&quot; cols=&quot;50&quot;&gt;多行文本&lt;/textarea&gt;&lt;button type=&quot;button&quot;&gt;按钮&lt;/button&gt;\n\n四、多媒体元素4.1 图片&lt;img src=&quot;image.jpg&quot; alt=&quot;图片描述&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;\n\n4.2 音视频&lt;audio controls&gt;    &lt;source src=&quot;audio.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/audio&gt;&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt;    &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;&lt;/video&gt;\n\n五、语义化元素5.1 HTML5 语义标签&lt;header&gt;页眉&lt;/header&gt;&lt;nav&gt;导航栏&lt;/nav&gt;&lt;main&gt;主要内容&lt;/main&gt;&lt;article&gt;独立内容&lt;/article&gt;&lt;section&gt;文档章节&lt;/section&gt;&lt;aside&gt;侧边内容&lt;/aside&gt;&lt;footer&gt;页脚&lt;/footer&gt;\n\n5.2 其他语义元素&lt;figure&gt;    &lt;img src=&quot;image.jpg&quot; alt=&quot;示例&quot;&gt;    &lt;figcaption&gt;图片说明&lt;/figcaption&gt;&lt;/figure&gt;&lt;time datetime=&quot;2023-10-01&quot;&gt;10月1日&lt;/time&gt;&lt;mark&gt;高亮文本&lt;/mark&gt;\n\n六、元数据与链接6.1 头部元数据&lt;meta name=&quot;description&quot; content=&quot;页面描述&quot;&gt;&lt;meta name=&quot;keywords&quot; content=&quot;HTML,CSS,JavaScript&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;&lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot;&gt;\n\n6.2 链接与锚点&lt;a href=&quot;https://example.com&quot;&gt;外部链接&lt;/a&gt;&lt;a href=&quot;#section1&quot;&gt;页面锚点&lt;/a&gt;&lt;a href=&quot;mailto:contact@example.com&quot;&gt;邮件链接&lt;/a&gt;&lt;a href=&quot;tel:+123456789&quot;&gt;电话链接&lt;/a&gt;\n\n七、全局属性7.1 常用全局属性\n\n\n属性\n说明\n\n\n\nid\n唯一标识\n\n\nclass\n类名\n\n\nstyle\n内联样式\n\n\ntitle\n提示文本\n\n\ndata-*\n自定义数据\n\n\nhidden\n隐藏元素\n\n\ntabindex\n键盘导航顺序\n\n\ncontenteditable\n可编辑内容\n\n\n\n八、字符实体8.1 常用字符实体&amp;nbsp;   &lt;!-- 空格 --&gt;&amp;lt;     &lt;!-- &lt; --&gt;&amp;gt;     &lt;!-- &gt; --&gt;&amp;amp;    &lt;!-- &amp; --&gt;&amp;copy;   &lt;!-- © --&gt;&amp;reg;    &lt;!-- ® --&gt;\n\n九、最佳实践\n使用语义化标签\n为图片添加alt属性\n表单元素关联label\n合理使用div和span\n遵循W3C标准\n保持代码缩进\n属性值使用双引号\n注释复杂结构\n考虑无障碍访问\n使用HTML验证器检查\n\n\n十、HTML5新特性10.1 新表单元素&lt;input type=&quot;color&quot;&gt;&lt;input type=&quot;range&quot;&gt;&lt;input type=&quot;search&quot;&gt;\n\n10.2 新API支持&lt;!-- 画布 --&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;&lt;!-- 本地存储 --&gt;&lt;script&gt;localStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);&lt;/script&gt;&lt;!-- 地理定位 --&gt;&lt;script&gt;navigator.geolocation.getCurrentPosition(showPosition);&lt;/script&gt;\n 注：HTML是网页的基础结构语言，通常与CSS和JavaScript配合使用构建现代网页应用。\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"没有激活Windows10/11的伙伴看过来！！！","url":"/2024/02/25/33.%E6%BF%80%E6%B4%BBWindows/","content":"前言我这里是Windows10&#x2F;11专业工作版(其他Windows版本也适用)如果你的设备是已经是结束支持的Windows7，请查阅其他相关是手册\n\n介绍这个神器叫 Microsoft Activation Scripts (MAS) ，是 github 上的一个开源项目。\n\n激活步骤1 一管理员身份打开powershell   方式1 搜索 powershell 并点击以管理员身份运行   方式2 使用快捷键 ‘Win’ +  ‘x’ + ‘A’\n2 输入代码在打开的界面中输入下面的代码。并等待\nirm https://massgrave.dev/get | iex\n3 选择代码无脑选择 1(表示永久激活)\n这时候输入 1，即可选择永久激活\n然后等待激活过程完成，出现 Press any key to Go back…就激活完场了\n\n注：激活office 也适用！！！\n","categories":["Windows"],"tags":["tool"]},{"title":"Javascript语言知识点汇总","url":"/2024/05/11/36-JavaScript/","content":"前言这里只是简单列出Javascript的知识点\n\n一、基础语法1.1 变量声明// ES5var name = &quot;张三&quot;; // 函数作用域// ES6+let age = 25;    // 块级作用域const PI = 3.14; // 常量\n\n1.2 数据类型\n\n\n类型\n说明\n示例\n\n\n\nNumber\n数字\n42, 3.14\n\n\nString\n字符串\n&quot;Hello&quot;, &#39;World&#39;\n\n\nBoolean\n布尔值\ntrue, false\n\n\nNull\n空值\nnull\n\n\nUndefined\n未定义\nundefined\n\n\nSymbol\n唯一值(ES6)\nSymbol(&#39;id&#39;)\n\n\nBigInt\n大整数(ES2020)\n123n\n\n\nObject\n对象\n&#123;name: &quot;张三&quot;&#125;\n\n\n1.3 类型检测typeof 42        // &quot;number&quot;typeof &quot;text&quot;    // &quot;string&quot;typeof true      // &quot;boolean&quot;typeof undefined // &quot;undefined&quot;typeof null      // &quot;object&quot; (历史遗留问题)Array.isArray([]) // true\n\n二、运算符2.1 算术运算符+ - * / % ** ++ --\n\n2.2 比较运算符==  // 相等(会类型转换)=== // 严格相等!=  // 不等!== // 严格不等&gt; &lt; &gt;= &lt;=\n\n2.3 逻辑运算符&amp;&amp; || ! ??\n\n2.4 赋值运算符= += -= *= /= %= **= &amp;&amp;= ||= ??=\n\n三、流程控制3.1 条件语句// if-elseif (age &gt; 18) &#123;    console.log(&quot;成年人&quot;);&#125; else &#123;    console.log(&quot;未成年人&quot;);&#125;// switchswitch(day) &#123;    case 1: console.log(&quot;周一&quot;); break;    default: console.log(&quot;周末&quot;);&#125;\n\n3.2 循环语句// for循环for (let i = 0; i &lt; 5; i++) &#123;    console.log(i);&#125;// while循环while (condition) &#123;    // ...&#125;// for...of (ES6)for (const item of array) &#123;    console.log(item);&#125;// for...in (遍历对象属性)for (const key in object) &#123;    console.log(key);&#125;\n\n四、函数4.1 函数定义// 函数声明function sum(a, b) &#123;    return a + b;&#125;// 函数表达式const multiply = function(a, b) &#123;    return a * b;&#125;;// 箭头函数(ES6)const divide = (a, b) =&gt; a / b;\n\n4.2 函数参数// 默认参数(ES6)function greet(name = &quot;Guest&quot;) &#123;    console.log(`Hello, $&#123;name&#125;!`);&#125;// 剩余参数(ES6)function sum(...numbers) &#123;    return numbers.reduce((a, b) =&gt; a + b);&#125;\n\n4.3 高阶函数// 回调函数function fetchData(callback) &#123;    setTimeout(() =&gt; callback(&quot;数据&quot;), 1000);&#125;// 返回函数function createAdder(x) &#123;    return y =&gt; x + y;&#125;\n\n五、对象与类5.1 对象创建// 对象字面量const person = &#123;    name: &quot;张三&quot;,    age: 30,    greet() &#123;        console.log(`我是$&#123;this.name&#125;`);    &#125;&#125;;// 构造函数function Person(name) &#123;    this.name = name;&#125;\n\n5.2 类(ES6)class Animal &#123;    constructor(name) &#123;        this.name = name;    &#125;        speak() &#123;        console.log(`$&#123;this.name&#125; makes a noise`);    &#125;&#125;class Dog extends Animal &#123;    speak() &#123;        super.speak();        console.log(`$&#123;this.name&#125; barks`);    &#125;&#125;\n\n六、数组操作6.1 常用方法const arr = [1, 2, 3];// 遍历arr.forEach(item =&gt; console.log(item));// 映射const doubled = arr.map(x =&gt; x * 2);// 过滤const evens = arr.filter(x =&gt; x % 2 === 0);// 查找const found = arr.find(x =&gt; x &gt; 1);// 排序arr.sort((a, b) =&gt; a - b);\n\n6.2 扩展运算符(ES6)const newArr = [...arr, 4, 5];const objCopy = &#123;...originalObj&#125;;\n\n七、异步编程7.1 Promiseconst promise = new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; resolve(&quot;成功&quot;), 1000);&#125;);promise    .then(result =&gt; console.log(result))    .catch(error =&gt; console.error(error));\n\n7.2 async&#x2F;await(ES2017)async function fetchData() &#123;    try &#123;        const response = await fetch(&#x27;url&#x27;);        const data = await response.json();        console.log(data);    &#125; catch (error) &#123;        console.error(error);    &#125;&#125;\n\n八、模块系统(ES6)8.1 导出// 命名导出export const name = &quot;张三&quot;;export function sayHi() &#123; /*...*/ &#125;// 默认导出export default class Person &#123; /*...*/ &#125;\n\n8.2 导入import &#123; name, sayHi &#125; from &#x27;./module.js&#x27;;import Person from &#x27;./Person.js&#x27;;\n\n九、现代JS特性9.1 解构赋值(ES6)const [a, b] = [1, 2];const &#123;name, age&#125; = person;\n\n9.2 可选链(ES2020)const street = user?.address?.street;\n\n9.3 空值合并(ES2020)const value = input ?? &quot;default&quot;;\n\n十、最佳实践\n使用严格模式(&quot;use strict&quot;)\n优先使用const&#x2F;let替代var\n使用&#x3D;&#x3D;&#x3D;代替&#x3D;&#x3D;\n避免全局变量污染\n函数单一职责原则\n错误处理(try&#x2F;catch)\n代码模块化组织\n编写可读性高的代码\n使用ESLint规范代码\n编写单元测试注：JavaScript是动态类型的解释型语言，遵循ECMAScript标准，本文涵盖ES5到ES2022主要特性。\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"CSS语言知识点汇总","url":"/2024/04/10/35.CSS/","content":"前言这里只是简单列出CSS的知识点\n\n一、基础语法1.1 基本结构selector &#123;    property: value;    /* 注释 */&#125;\n\n1.2 引入方式&lt;!-- 内联样式 --&gt;&lt;div style=&quot;color: red;&quot;&gt;&lt;/div&gt;&lt;!-- 内部样式表 --&gt;&lt;style&gt;    body &#123; font-family: Arial; &#125;&lt;/style&gt;&lt;!-- 外部样式表 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;\n\n二、选择器2.1 基本选择器\n\n\n选择器\n示例\n说明\n\n\n\n元素选择器\np\n选择所有元素\n\n\n类选择器\n.class\n选择class&#x3D;”class”的元素\n\n\nID选择器\n#id\n选择id&#x3D;”id”的元素\n\n\n通配符\n*\n选择所有元素\n\n\n2.2 组合选择器\n\n\n选择器\n示例\n说明\n\n\n\n后代选择器\ndiv p\n选择div内的所有p元素\n\n\n子元素选择器\ndiv &gt; p\n选择div的直接子元素p\n\n\n相邻兄弟\nh1 + p\n选择紧接在h1后的p元素\n\n\n通用兄弟\nh1 ~ p\n选择h1后的所有p兄弟元素\n\n\n2.3 属性选择器[attribute]          /* 具有该属性 */[attribute=&quot;value&quot;]  /* 属性等于value */[attribute^=&quot;val&quot;]   /* 属性以val开头 */[attribute$=&quot;ue&quot;]    /* 属性以ue结尾 */[attribute*=&quot;alu&quot;]   /* 属性包含alu */\n\n2.4 伪类与伪元素/* 伪类 */a:hover &#123;&#125;      /* 鼠标悬停 */li:nth-child(2) &#123;&#125; /* 第二个li *//* 伪元素 */p::first-line &#123;&#125; /* 第一行文本 */p::before &#123;&#125;    /* 在元素前插入内容 */\n\n三、盒模型3.1 标准盒模型内容区 → padding → border → margin\n\n3.2 相关属性.box &#123;    width: 300px;    height: 200px;    padding: 20px;    border: 5px solid black;    margin: 10px;    box-sizing: border-box; /* IE盒模型 */&#125;\n\n四、常用属性4.1 文本样式p &#123;    color: #333;    font-size: 16px;    font-family: &quot;Microsoft YaHei&quot;;    line-height: 1.5;    text-align: center;    text-decoration: none;&#125;\n\n4.2 背景样式div &#123;    background-color: #fff;    background-image: url(&quot;bg.jpg&quot;);    background-repeat: no-repeat;    background-position: center;    background-size: cover;&#125;\n\n4.3 边框与圆角.btn &#123;    border: 1px solid #ccc;    border-radius: 4px;    box-shadow: 2px 2px 5px rgba(0,0,0,0.1);&#125;\n\n五、布局方式5.1 Flex布局.container &#123;    display: flex;    justify-content: space-between;    align-items: center;    flex-wrap: wrap;&#125;.item &#123;    flex: 1;&#125;\n\n5.2 Grid布局.grid &#123;    display: grid;    grid-template-columns: 1fr 2fr;    gap: 20px;&#125;\n\n5.3 定位.absolute &#123;    position: absolute;    top: 10px;    left: 20px;    z-index: 10;&#125;\n\n六、响应式设计6.1 媒体查询@media (max-width: 768px) &#123;    .menu &#123; display: none; &#125;&#125;\n\n6.2 视口单位.header &#123;    height: 100vh; /* 视口高度 */    width: 100vw;  /* 视口宽度 */    font-size: 5vmin; /* 视口较小尺寸的5% */&#125;\n\n七、动画与过渡7.1 过渡效果.button &#123;    transition: all 0.3s ease-in-out;&#125;.button:hover &#123;    transform: scale(1.1);&#125;\n\n7.2 关键帧动画@keyframes slidein &#123;    from &#123; transform: translateX(-100%); &#125;    to &#123; transform: translateX(0); &#125;&#125;.slide &#123;    animation: slidein 1s forwards;&#125;\n\n八、CSS变量:root &#123;    --primary-color: #4285f4;    --spacing: 16px;&#125;.element &#123;    color: var(--primary-color);    padding: var(--spacing);&#125;\n\n九、最佳实践\n使用语义化类名（BEM规范）\n避免使用!important\n合理使用继承属性\n样式模块化组织\n使用CSS预处理器（Sass&#x2F;Less）\n添加浏览器前缀（autoprefixer）\n移动端优先设计\n性能优化（减少重绘回流）\n使用CSS Reset&#x2F;Normalize\n保持代码可维护性\n\n\n十、现代CSS特性10.1 CSS3新特性/* 多列布局 */.columns &#123;    column-count: 3;    column-gap: 20px;&#125;/* 滤镜效果 */.image &#123;    filter: blur(5px) grayscale(50%);&#125;/* 混合模式 */.overlay &#123;    mix-blend-mode: multiply;&#125;\n\n\n注：CSS是网页样式描述语言，与HTML和JavaScript共同构成网页开发三大核心技术。\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"C++面向对象编程","url":"/2024/06/21/37.C++%E7%9A%84class/","content":"前言这里只是简单列出C++中面向对象编程的知识点\n\n一、概述面向对象编程（OOP）是C++的核心范式，通过封装、继承、多态三大特性构建程序结构。C++在C语言基础上添加了类等面向对象特性，既支持过程化编程也支持面向对象编程，具有高度的灵活性和性能。\n\n二、核心特性详解2.1 类与对象（封装）2.1.1 基本类定义class Person &#123;private:    // 访问修饰符    string name;  // 成员变量    int age;    public:    // 构造函数    Person(string n, int a) : name(n), age(a) &#123;&#125;        // 成员函数    void introduce() &#123;        cout &lt;&lt; &quot;I&#x27;m &quot; &lt;&lt; name &lt;&lt; &quot;, &quot; &lt;&lt; age &lt;&lt; &quot; years old.&quot; &lt;&lt; endl;    &#125;        // setter/getter    void setAge(int a) &#123; age = a; &#125;    int getAge() const &#123; return age; &#125;&#125;;\n\n2.1.2 特殊成员函数class Example &#123;public:    Example();                      // 默认构造函数    Example(const Example&amp;);        // 拷贝构造函数    Example&amp; operator=(const Example&amp;); // 拷贝赋值运算符    ~Example();                     // 析构函数    Example(Example&amp;&amp;);             // 移动构造函数(C++11)    Example&amp; operator=(Example&amp;&amp;);  // 移动赋值运算符(C++11)&#125;;\n\n2.2 继承与派生2.2.1 继承基础class Student : public Person &#123;  // 公有继承private:    int grade;public:    Student(string n, int a, int g) : Person(n, a), grade(g) &#123;&#125;        // 方法重写    void introduce() &#123;        Person::introduce();  // 调用基类方法        cout &lt;&lt; &quot;Grade: &quot; &lt;&lt; grade &lt;&lt; endl;    &#125;&#125;;\n\n2.2.2 继承类型\n\n\n继承方式\n基类public成员\n基类protected成员\n基类private成员\n\n\n\npublic\npublic\nprotected\n不可访问\n\n\nprotected\nprotected\nprotected\n不可访问\n\n\nprivate\nprivate\nprivate\n不可访问\n\n\n2.3 多态与虚函数2.3.1 虚函数机制class Shape &#123;public:    virtual double area() const = 0;  // 纯虚函数(抽象类)    virtual ~Shape() &#123;&#125;               // 虚析构函数&#125;;class Circle : public Shape &#123;    double radius;public:    double area() const override &#123;    // 重写虚函数        return 3.14 * radius * radius;    &#125;&#125;;\n\n2.3.2 多态应用void printArea(const Shape&amp; shape) &#123;    cout &lt;&lt; &quot;Area: &quot; &lt;&lt; shape.area() &lt;&lt; endl;&#125;// 使用Circle c(5.0);printArea(c);  // 动态绑定调用Circle::area()\n\n2.4 运算符重载class Vector &#123;    double x, y;public:    Vector operator+(const Vector&amp; other) const &#123;        return Vector(x + other.x, y + other.y);    &#125;        // 输出运算符重载    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Vector&amp; v) &#123;        return os &lt;&lt; &quot;(&quot; &lt;&lt; v.x &lt;&lt; &quot;, &quot; &lt;&lt; v.y &lt;&lt; &quot;)&quot;;    &#125;&#125;;\n\n2.5 友元与静态成员class BankAccount &#123;private:    double balance;    static int totalAccounts;  // 静态成员    public:    friend class BankManager;  // 友元类        static int getTotalAccounts() &#123;  // 静态方法        return totalAccounts;    &#125;&#125;;int BankAccount::totalAccounts = 0;  // 静态成员初始化\n\n三、高级特性3.1 多重继承class TA : public Teacher, public Student &#123;    // 可能产生菱形继承问题    // 需要使用虚继承解决&#125;;\n\n3.2 RTTI（运行时类型识别）Base* ptr = new Derived();if (Derived* d = dynamic_cast&lt;Derived*&gt;(ptr)) &#123;    // 转换成功&#125;\n\n3.3 现代C++特性（C++11&#x2F;14&#x2F;17）3.3.1 override&#x2F;finalclass Base &#123;public:    virtual void foo() final;  // 禁止重写&#125;;class Derived : public Base &#123;public:    void foo() override;  // 显式声明重写&#125;;\n\n3.3.2 移动语义class ResourceHolder &#123;    int* data;public:    ResourceHolder(ResourceHolder&amp;&amp; other) noexcept  // 移动构造函数        : data(other.data) &#123;        other.data = nullptr;    &#125;&#125;;\n\n四、总结4.1 面向对象优势\n封装：隐藏实现细节，提供清晰接口\n继承：代码复用和层次化设计\n多态：统一接口，不同实现\n\n4.2 最佳实践建议\n优先使用组合而非继承\n遵循单一职责原则\n为多态基类声明虚析构函数\n避免过度使用友元\n合理使用const成员函数\n注意对象生命周期管理\n使用智能指针管理资源\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"C++标准模板库(STL)","url":"/2024/07/01/38.STL/","content":"前言这里只是简单列出C++标准模板库(STL)\n\n一、概述标准模板库(STL)是C++标准库的核心组成部分，提供了一套通用、高效的模板类和函数。STL基于泛型编程思想，包含容器(Containers)、**算法(Algorithms)和迭代器(Iterators)**三大核心组件，以及函数对象(Functors)、适配器(Adapters)和分配器(Allocators)等辅助组件。\n\n二、核心组件详解2.1 容器(Containers)2.1.1 序列式容器\n\n\n容器\n特性\n典型操作\n\n\n\nvector\n动态数组，随机访问快\npush_back, emplace_back\n\n\ndeque\n双端队列，头尾插入高效\npush_front, pop_back\n\n\nlist\n双向链表\nsplice, merge\n\n\nforward_list\n单向链表(C++11)\ninsert_after\n\n\narray\n固定大小数组(C++11)\nfill, size\n\n\nvector&lt;int&gt; v = &#123;1,2,3&#125;;v.push_back(4);  // O(1)摊销sort(v.begin(), v.end());\n\n2.1.2 关联式容器\n\n\n容器\n特性\n底层实现\n\n\n\nset\n唯一键集合，自动排序\n红黑树\n\n\nmultiset\n允许重复键的集合\n红黑树\n\n\nmap\n键值对映射\n红黑树\n\n\nmultimap\n允许重复键的映射\n红黑树\n\n\nmap&lt;string, int&gt; m = &#123;&#123;&quot;Alice&quot;, 25&#125;, &#123;&quot;Bob&quot;, 30&#125;&#125;;m[&quot;Charlie&quot;] = 28;  // O(log n)\n\n2.1.3 无序关联容器(C++11)\n\n\n容器\n特性\n底层实现\n\n\n\nunordered_set\n哈希集合\n哈希表\n\n\nunordered_map\n哈希映射\n哈希表\n\n\nunordered_multiset\n可重复哈希集合\n哈希表\n\n\nunordered_multimap\n可重复哈希映射\n哈希表\n\n\nunordered_map&lt;string, int&gt; um = &#123;&#123;&quot;apple&quot;, 5&#125;, &#123;&quot;banana&quot;, 3&#125;&#125;;cout &lt;&lt; um.at(&quot;apple&quot;);  // O(1)平均\n\n2.2 迭代器(Iterators)2.2.1 迭代器类别\n\n\n类型\n支持操作\n对应容器示例\n\n\n\n输入迭代器\n只读，单遍扫描\nistream_iterator\n\n\n输出迭代器\n只写，单遍扫描\nostream_iterator\n\n\n前向迭代器\n读写，多遍扫描\nforward_list\n\n\n双向迭代器\n可双向移动\nlist, set\n\n\n随机访问迭代器\n支持算术运算\nvector, deque\n\n\nvector&lt;int&gt;::iterator it = v.begin();advance(it, 2);  // 移动迭代器\n\n2.3 算法(Algorithms)2.3.1 常用算法分类\n\n\n分类\n示例算法\n说明\n\n\n\n非修改序列\nfind, count, for_each\n不改变容器内容\n\n\n修改序列\ncopy, replace, remove\n可能改变容器内容\n\n\n排序相关\nsort, partial_sort\n各种排序操作\n\n\n数值运算\naccumulate, inner_product\n数学计算\n\n\nvector&lt;int&gt; v = &#123;5,3,1,4,2&#125;;sort(v.begin(), v.end());  // 默认升序reverse(v.begin(), v.end());\n\n2.4 函数对象(Functors)与Lambda(C++11)// 函数对象struct Compare &#123;    bool operator()(int a, int b) const &#123;        return a &gt; b;  // 降序比较    &#125;&#125;;sort(v.begin(), v.end(), Compare());// Lambda表达式sort(v.begin(), v.end(), [](int a, int b) &#123;    return a &lt; b;  // 升序&#125;);\n\n三、实用组件3.1 适配器(Adapters)3.1.1 容器适配器stack&lt;int&gt; s;       // 默认基于dequequeue&lt;double&gt; q;    // 默认基于dequepriority_queue&lt;int&gt; pq;  // 默认基于vector\n\n3.1.2 迭代器适配器vector&lt;int&gt; v = &#123;1,2,3&#125;;reverse_iterator&lt;vector&lt;int&gt;::iterator&gt; rit(v.end());cout &lt;&lt; *rit;  // 输出3\n\n3.2 智能指针(C++11&#x2F;14)unique_ptr&lt;int&gt; up(new int(5));  // 独占所有权shared_ptr&lt;int&gt; sp = make_shared&lt;int&gt;(10);  // 共享所有权weak_ptr&lt;int&gt; wp = sp;  // 弱引用\n\n3.3 元组(C++11)与可选值(C++17)tuple&lt;string, int, double&gt; t(&quot;Alice&quot;, 25, 3.8);auto [name, age, gpa] = t;  // 结构化绑定(C++17)optional&lt;int&gt; findValue(...) &#123;  // 可能无返回值    if (...) return 42;    return nullopt;&#125;\n\n四、现代C++特性4.1 移动语义优化(C++11)vector&lt;string&gt; createStrings() &#123;    vector&lt;string&gt; v;    v.push_back(&quot;large string&quot;);    return v;  // 触发移动构造而非拷贝&#125;\n\n4.2 并行算法(C++17)vector&lt;int&gt; bigData(1000000);sort(execution::par, bigData.begin(), bigData.end());  // 并行排序\n\n4.3 范围库(C++20)vector&lt;int&gt; v = &#123;5,3,2,4,1&#125;;auto even = v | views::filter([](int x)&#123; return x%2==0; &#125;);ranges::sort(v);  // 更简洁的语法\n\n五、总结与最佳实践5.1 STL优势\n通用性：模板支持任意符合要求的类型\n高效性：经过高度优化的实现\n可扩展性：可与自定义组件无缝集成\n\n5.2 使用建议\n优先选择STL而非原始数组\n根据场景选择合适的容器：\n随机访问：vector&#x2F;array\n频繁插入删除：list&#x2F;forward_list\n快速查找：set&#x2F;map或无序容器\n\n\n使用emplace操作避免临时对象\n注意迭代器失效问题\n利用算法替代手写循环\n现代C++中优先使用智能指针管理资源\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"离谱 office tool plus？？？","url":"/2021/09/14/4.office%20tool%20plus/","content":"前言我这里是Windows10&#x2F;11专业工作版(其他Windows版本也适用)如果你的设备是已经是结束支持的Windows7，请查阅其他相关是手册office是什么？Office办公软件是一套由微软公司开发的办公软件，它为 Microsoft Windows 和 Mac OS X而开发。与办公室应用程序一样，它包括联合的服务器和基于互联网的服务。最近版本的 Office 被称为 “Office system” 而不叫 “Office suite”，反映出它们也包括服务器的事实。该软件被认为是一个开发文档的事实标准，而且有一些特性在其他产品中并不存在；但是其他产品也有 Office 缺少的特性。2007 Microsoft Office System 有一个和以前版本差异很大的用户界面。常用组件有 Word、Excel、PowerPoint等。最新版本为Office 365(Office 2021)。定价有按年定价和按月定价(不管是那种方式都可以免费试用 1 个月)定价如下如你所见，office的价格是很令人感动的,那么有没有什么方式我们能使用完整版本的office呢？答案肯定是有的！！！office tool plusoffice tool plus是你不错的选择\n什么是 office tool plusOffice Tool Plus 是一款基于 Office 部署工具 (ODT) 开发的免费工具，具有以下主要功能：快速下载 Office，支持所有版本（Office 2016-2024，Microsoft 365）。灵活安装和配置 Office，包括语言、版本、应用程序选择等。支持通过 KMS 等方式激活 Office，方便批量许可证管理。提供一键修复功能，帮助解决安装或激活问题。\noffice tool plus 的下载office tool plus 下载地址点击下载地址链接，进入office tool plus的官方下载地址注意：office tool plus 的系统要求：Windows 10 或更高版本，不支持其他操作系统（例如 Linux 或 macOS）\n部署office将Office tool plus 解压到桌面上，打开office tool plus.exe 文件点击部署选择自己需要的office 版本这里我选择的是office 365 和Viso 2021 专业版 和 project 2021 专业版选择语言为 简体中文 点击部署就好了\n激活offce部署结束了后，使用快捷键 Ctrl + shift +p 键调出激活代码框输入\nospp /inslicid MondoVolume /sethst:kms.loli.beer /setprt:1688 /act\n结语1、下载office tool plus2、打开office tool plus.exe文件3、选择自己需要的部件，选择语言，点击部署4、调出激活代码框，输入激活代码","categories":["Windows"],"tags":["Office"]},{"title":"Lua语言知识点汇总","url":"/2024/08/01/39-Lua/","content":"前言这里只是简单列出Lua语言的知识点\n\n一、基础语法1.1 注释-- 单行注释--[[  多行注释  可以跨越多行]]\n\n1.2 变量声明a = 10           -- 全局变量local b = 20     -- 局部变量c, d = 30, &quot;Lua&quot; -- 多重赋值\n\n1.3 数据类型\n\n\n类型\n说明\n示例\n\n\n\nnil\n空值\nlocal x = nil\n\n\nboolean\n布尔值\ntrue, false\n\n\nnumber\n数字\n3.14, 42\n\n\nstring\n字符串\n&quot;Hello&quot;, &#39;World&#39;\n\n\ntable\n表&#x2F;数组\n&#123;1, 2, 3&#125;\n\n\nfunction\n函数\nfunction() end\n\n\nthread\n协程\ncoroutine.create()\n\n\nuserdata\n自定义数据\n用于C交互\n\n\n\n二、运算符2.1 算术运算符+ - * / % ^   -- 加减乘除取模幂\n\n2.2 关系运算符== ~= &lt; &gt; &lt;= &gt;=\n\n2.3 逻辑运算符and or not\n\n2.4 字符串连接local s = &quot;Hello&quot; .. &quot; &quot; .. &quot;Lua!&quot;  -- &quot;Hello Lua!&quot;\n\n2.5 长度运算符local len = #&quot;Lua&quot;  -- 3local tbl = &#123;1,2,3&#125;print(#tbl)         -- 3\n\n三、控制结构3.1 条件语句if score &gt;= 90 then    print(&quot;A&quot;)elseif score &gt;= 80 then    print(&quot;B&quot;)else    print(&quot;C&quot;)end\n\n3.2 循环语句-- while循环local i = 1while i &lt;= 5 do    print(i)    i = i + 1end-- for循环for i = 1, 5 do    print(i)end-- 步长循环for i = 10, 1, -2 do    print(i)  -- 10,8,6,4,2end-- repeat until循环local j = 1repeat    print(j)    j = j + 1until j &gt; 5\n\n四、函数4.1 函数定义function add(a, b)    return a + bend-- 匿名函数local multiply = function(a, b)     return a * b end\n\n4.2 多重返回值function getUser()    return &quot;Alice&quot;, 30endlocal name, age = getUser()\n\n4.3 变长参数function sum(...)    local total = 0    for _, v in ipairs(&#123;...&#125;) do        total = total + v    end    return totalendprint(sum(1,2,3,4))  -- 10\n\n五、表（Table）5.1 基本操作-- 数组式表local arr = &#123;10, 20, 30&#125;print(arr[1])  -- 10（Lua索引从1开始）-- 字典式表local person = &#123;    name = &quot;Bob&quot;,    age = 25,    sayHello = function()        print(&quot;Hello!&quot;)    end&#125;print(person.name)  -- &quot;Bob&quot;person.sayHello()   -- &quot;Hello!&quot;\n\n5.2 表操作函数local t = &#123;3, 1, 4&#125;table.insert(t, 2, 5)  -- 插入元素: &#123;3,5,1,4&#125;table.remove(t, 3)      -- 删除元素: &#123;3,5,4&#125;table.sort(t)           -- 排序: &#123;3,4,5&#125;\n\n六、元表（Metatable）6.1 元表基础local t1 = &#123;10, 20&#125;local mt = &#123;    __index = function(t, k)        return &quot;Key not found: &quot; .. k    end&#125;setmetatable(t1, mt)print(t1[3])  -- &quot;Key not found: 3&quot;\n\n6.2 运算符重载local v1 = &#123;x=1, y=2&#125;local v2 = &#123;x=3, y=4&#125;local mt = &#123;    __add = function(a, b)        return &#123;x = a.x + b.x, y = a.y + b.y&#125;    end&#125;setmetatable(v1, mt)setmetatable(v2, mt)local v3 = v1 + v2print(v3.x, v3.y)  -- 4, 6\n\n七、模块系统7.1 创建模块-- mymodule.lualocal M = &#123;&#125;function M.add(a, b)    return a + bendfunction M.subtract(a, b)    return a - bendreturn M\n\n7.2 使用模块local math = require &quot;mymodule&quot;print(math.add(5, 3))  -- 8\n\n八、协程（Coroutines）8.1 协程基础local co = coroutine.create(function()    print(&quot;Start&quot;)    coroutine.yield()    print(&quot;End&quot;)end)coroutine.resume(co)  -- 输出 &quot;Start&quot;coroutine.resume(co)  -- 输出 &quot;End&quot;\n\n8.2 生产者-消费者模式function producer()    local i = 0    return function()        i = i + 1        return i    endendfunction consumer(prod)    while true do        local value = prod()        print(&quot;Consumed:&quot;, value)        coroutine.yield()    endendlocal p = producer()local co = coroutine.create(consumer, p)for i = 1, 5 do    coroutine.resume(co)end\n\n九、文件操作9.1 文件读写-- 写入文件local file = io.open(&quot;test.txt&quot;, &quot;w&quot;)file:write(&quot;Hello Lua!\\n&quot;)file:close()-- 读取文件local file = io.open(&quot;test.txt&quot;, &quot;r&quot;)local content = file:read(&quot;*a&quot;)print(content)  -- &quot;Hello Lua!&quot;file:close()\n\n十、错误处理10.1 pcall 和 xpcalllocal success, result = pcall(function()    error(&quot;Something went wrong&quot;)end)if not success then    print(&quot;Error:&quot;, result)end\n\n10.2 assertlocal value = -5assert(value &gt;= 0, &quot;Value must be non-negative&quot;)-- 抛出错误: Value must be non-negative\n\n十一、标准库11.1 常用模块\n\n\n模块\n用途\n\n\n\nstring\n字符串处理\n\n\ntable\n表操作\n\n\nmath\n数学函数\n\n\nio\n输入输出\n\n\nos\n操作系统接口\n\n\ndebug\n调试工具\n\n\ncoroutine\n协程支持\n\n\npackage\n模块管理\n\n\n11.2 常用函数print(&quot;Hello&quot;)                   -- 输出type(42)                         -- &quot;number&quot;tonumber(&quot;123&quot;)                  -- 123tostring(123)                    -- &quot;123&quot;pcall(func)                      -- 保护调用next(t)                          -- 遍历表collectgarbage()                 -- 垃圾回收\n\n\n十二、最佳实践\n使用局部变量：默认使用 local 声明变量\n避免全局污染：使用模块组织代码\n正确处理nil：避免对nil值进行操作\n利用元表：实现面向对象和运算符重载\n合理使用协程：实现协作式多任务\n资源管理：及时关闭文件和释放资源\n错误处理：使用pcall保护关键代码\n表设计：区分数组部分和哈希部分\n性能优化：避免在循环中创建表\n代码规范：保持一致的命名和缩进风格\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"C++与泛型编程","url":"/2024/09/09/40.C++%E4%B8%8E%E6%B3%9B%E5%BC%8F%E7%BC%96%E7%A8%8B/","content":"前言这里只是简单列出C++语言与泛型编程\n\n总述：泛型编程的核心概念泛型编程是C++的核心编程范式之一，通过参数化类型实现代码复用。其核心思想是编写与数据类型无关的通用代码，主要依赖模板机制实现。泛型编程优势包括：\n\n类型安全：编译时类型检查\n性能优化：避免运行时开销\n代码复用：减少重复代码\n抽象提升：更高层次的算法抽象\n\n\n分述：核心语法与特性1. 函数模板template &lt;typename T&gt;T max(T a, T b) &#123;    return (a &gt; b) ? a : b;&#125;// 使用int m1 = max(10, 20);              // 隐式实例化double m2 = max&lt;double&gt;(5.5, 3.2); // 显式实例化\n\n2. 类模板template &lt;typename T, int Size&gt;class Array &#123;private:    T data[Size];public:    T&amp; operator[](int index) &#123;        return data[index];    &#125;&#125;;// 使用Array&lt;int, 5&gt; intArr;Array&lt;std::string, 10&gt; strArr;\n\n3. 模板特化// 主模板template &lt;typename T&gt;class Printer &#123;public:    void print(const T&amp; value) &#123;        std::cout &lt;&lt; &quot;Value: &quot; &lt;&lt; value &lt;&lt; std::endl;    &#125;&#125;;// 全特化template &lt;&gt;class Printer&lt;std::string&gt; &#123;public:    void print(const std::string&amp; value) &#123;        std::cout &lt;&lt; &quot;String: &quot; &lt;&lt; value &lt;&lt; std::endl;    &#125;&#125;;// 偏特化template &lt;typename T&gt;class Printer&lt;T*&gt; &#123;public:    void print(const T* value) &#123;        std::cout &lt;&lt; &quot;Pointer: &quot; &lt;&lt; *value &lt;&lt; std::endl;    &#125;&#125;;\n\n4. 非类型模板参数template &lt;int N&gt;struct Factorial &#123;    static const int value = N * Factorial&lt;N-1&gt;::value;&#125;;template &lt;&gt;struct Factorial&lt;0&gt; &#123;    static const int value = 1;&#125;;int main() &#123;    std::cout &lt;&lt; Factorial&lt;5&gt;::value; // 输出120&#125;\n\n5. 变长参数模板(C++11)// 递归终止函数void print() &#123;&#125;template &lt;typename T, typename... Args&gt;void print(T first, Args... args) &#123;    std::cout &lt;&lt; first &lt;&lt; &quot; &quot;;    print(args...);&#125;// 折叠表达式(C++17)template &lt;typename... Args&gt;auto sum(Args... args) &#123;    return (args + ...); // 折叠表达式&#125;\n\n6. 类型萃取与SFINAE// 使用enable_iftemplate &lt;typename T&gt;typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::typeincrement(T value) &#123;    return value + 1;&#125;// 概念约束(C++20)template &lt;std::integral T&gt;T decrement(T value) &#123;    return value - 1;&#125;\n\n7. 模板元编程// 编译时判断素数template &lt;int N, int D = N-1&gt;struct IsPrime &#123;    static const bool value = (N % D != 0) &amp;&amp; IsPrime&lt;N, D-1&gt;::value;&#125;;template &lt;int N&gt;struct IsPrime&lt;N, 1&gt; &#123;    static const bool value = true;&#125;;template &lt;int N&gt;struct IsPrime&lt;N, 0&gt; &#123;    static const bool value = false;&#125;;\n\n8. 别名模板(C++11)template &lt;typename T&gt;using Vec = std::vector&lt;T, CustomAllocator&lt;T&gt;&gt;;// 使用Vec&lt;int&gt; customVector; // 使用自定义分配器的vector\n\n9. 变量模板(C++14)template &lt;typename T&gt;constexpr T pi = T(3.1415926535897932385);// 使用float f = pi&lt;float&gt;;double d = pi&lt;double&gt;;\n\n\n总结：泛型编程的应用与最佳实践泛型编程在C++中的典型应用场景包括：\n\n标准库容器：vector, list, map等\n通用算法：sort, find, transform等\n智能指针：unique_ptr, shared_ptr\n类型擦除：any, function\n元编程工具：type_traits, enable_if\n\n最佳实践原则：\n\n优先使用STL：避免重复造轮子\n限制模板类型：使用static_assert或概念约束\n避免过度泛化：平衡通用性与可读性\n注意代码膨胀：合理使用显式实例化\n利用编译时计算：提升运行时性能\n\n随着C++20引入概念(Concepts)，泛型编程进入新阶段：\n// 使用概念约束template &lt;typename T&gt;concept Addable = requires(T a, T b) &#123;    &#123; a + b &#125; -&gt; std::convertible_to&lt;T&gt;;&#125;;template &lt;Addable T&gt;T add(T a, T b) &#123;    return a + b;&#125;\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"三周年 - 特别篇","url":"/2024/06/06/37.years3/","content":"【我的小窝也三岁了】致我的小窝：三周年快乐\n亲爱的网站，当我看到“建站36个月”的提示时，指尖在键盘上悬了很久——原来你已经陪我走过一千多个日夜，从一个跌跌撞撞的小页面，长成了藏着我无数心事的“电子树洞”。\n还记得最初遇见你时，我盯着空白的模板手足无措，像捧着空本子的小学生，不知道该往你怀里塞些什么。后来慢慢懂了：你是可以装下我笨拙的文字、未完成的插画、甚至是凌晨三点突然冒出来的碎碎念的地方。那些在朋友圈不敢发的“矫情”，在对话框没说完的“犹豫”，都被你悄悄收进了“存档”——原来最温暖的陪伴，是有人（哪怕是个沉默的小空间）愿意接住你所有的“不完美”。\n这三年里，你见证了我太多变化：从写第一篇博客时反复删改十几次，到现在敢大大方方分享“今天又搞砸了一件事”；从为了涨粉焦虑到明白“哪怕只有一个人点开，也是一次温柔的相遇”；甚至看着你从简陋的模板换成自定义界面，像看着自己亲手搭的小房子慢慢装上了暖灯、种上了花草——原来成长从来不是孤孤单单的奔跑，是有人陪你一起“打怪升级”，哪怕只是个不会说话的小网站。\n当然，也有过想放弃的时刻：没有更新内容时，被现实琐事挤得没空更新时，甚至怀疑“自己写的东西有没有意义”时，只要想到我写的对小伙伴们有帮助就忽然觉得：哪怕你只是互联网海洋里最不起眼的小贝壳，也在某个瞬间，曾被某双眼睛温柔地捡起过。这种“被需要”的微光，让我总想再为你多写一点，多装点一点。\n今天想对你说声“谢谢”：谢谢你让我在这个快节奏的世界里，有个可以慢下来的角落；谢谢你让我知道，哪怕没人鼓掌，认真记录生活本身就很了不起；更谢谢你，让我在和你相处的日子里，慢慢学会了和自己和解——原来比起“成为厉害的人”，“成为愿意和自己好好相处的人”更重要。\n下一个三年，或许你会迎来更多变化：界面会迭代，风格会改变，甚至可能会有新的“小伙伴”加入，但希望我们能一直记得初心——你还是那个不judge我的“秘密基地”，我还是那个愿意把真心摊开给你看的人。哪怕未来互联网浪潮汹涌，只要你还在，我就还有个可以回头的“家”。\n最后，想给你盖一座“电子小蛋糕”：三层奶油分别是“不焦虑”“慢慢来”“继续热爱”，顶上插满会发光的“小梦想”——愿我们下一个周年日，依然能笑着说：“嘿，这一年，我们又认真活过了呢。”\n","categories":["特别篇"],"tags":["Anniversary"]},{"title":"C++与虚拟","url":"/2024/09/10/40.c++%E7%9A%84%E8%99%9A%E6%8B%9F/","content":"前言这里只是简单列出C++语言与虚拟（virtual）\n\n总述：虚拟机制的核心价值虚拟（virtual）机制是C++实现运行时多态的核心语法，通过动态绑定（Dynamic Binding） 实现面向对象编程的三大特性之一——多态性。其本质是在运行时根据对象类型决定调用哪个函数版本，主要解决以下问题：\n\n基类指针&#x2F;引用调用派生类方法的问题\n对象类型识别（RTTI） 的底层支持\n接口与实现分离的设计需求\n可扩展框架的构建基础\n\n\n核心组件：虚函数 | 抽象类 | 虚继承 | 虚析构函数 | 动态类型转换\n\n\n分述：虚拟语法体系详解一、虚函数（Virtual Functions）1. 基本语法与原理class Base &#123;public:    virtual void func() &#123;  // 虚函数声明        cout &lt;&lt; &quot;Base::func()&quot; &lt;&lt; endl;    &#125;&#125;;class Derived : public Base &#123;public:    void func() override &#123;  // 重写虚函数        cout &lt;&lt; &quot;Derived::func()&quot; &lt;&lt; endl;    &#125;&#125;;// 使用Base* b = new Derived();b-&gt;func();  // 输出&quot;Derived::func()&quot; - 动态绑定\n\n关键机制：\n\n虚函数表（vtable）：每个含虚函数的类拥有一个虚表\n虚指针（vptr）：每个对象隐含指针指向虚表\n动态绑定：运行时通过vptr查找调用正确函数\n\n2. override 与 final 限定符（C++11）class Derived2 : public Derived &#123;public:    void func() final &#123;  // 禁止进一步重写        cout &lt;&lt; &quot;Derived2::func()&quot; &lt;&lt; endl;    &#125;&#125;;class Derived3 : public Derived2 &#123;public:    // 错误：func()在Derived2中已声明final    // void func() override &#123;&#125;&#125;;\n\n二、纯虚函数与抽象类1. 纯虚函数定义class Shape &#123;  // 抽象类public:    virtual double area() const = 0;  // 纯虚函数    virtual void draw() = 0;         // 纯虚函数&#125;;\n\n2. 抽象类特性\n不能实例化：Shape s; 会导致编译错误\n强制接口实现：派生类必须实现所有纯虚函数\n可包含实现：抽象类可提供普通成员函数实现\n\n三、虚析构函数（Critical!）1. 必要性演示class Base &#123;public:    ~Base() &#123; cout &lt;&lt; &quot;~Base()&quot; &lt;&lt; endl; &#125; // 非虚析构&#125;;class Derived : public Base &#123;public:    ~Derived() &#123; cout &lt;&lt; &quot;~Derived()&quot; &lt;&lt; endl; &#125;&#125;;Base* b = new Derived();delete b;  // 仅输出&quot;~Base()&quot; - 内存泄漏！\n\n2. 正确实现class Base &#123;public:    virtual ~Base() &#123;  // 虚析构函数        cout &lt;&lt; &quot;~Base()&quot; &lt;&lt; endl;    &#125;&#125;;delete b;  // 现在输出：&quot;~Derived()&quot; → &quot;~Base()&quot;\n\n\n黄金规则：任何作为基类的类型必须声明虚析构函数\n\n四、虚继承（Virtual Inheritance）1. 解决菱形继承问题classDiagram    class A    class B : virtual public A    class C : virtual public A    class D : public B, public C\n\n2. 语法实现class A &#123; int data; &#125;;class B : virtual public A &#123;&#125;;  // 虚继承class C : virtual public A &#123;&#125;;  // 虚继承class D : public B, public C &#123;&#125;;D d;d.data = 10;  // 无二义性 - 单一A子对象\n\n底层机制：\n\n虚基类表（vbtable）：存储虚基类偏移量\n共享实例：虚基类在派生类中只有一份拷贝\n\n五、RTTI（运行时类型识别）1. typeid 运算符Base* ptr = new Derived();if (typeid(*ptr) == typeid(Derived)) &#123;    cout &lt;&lt; &quot;指向Derived对象&quot; &lt;&lt; endl;&#125;\n\n2. dynamic_cast 转换Base* b = new Derived();Derived* d = dynamic_cast&lt;Derived*&gt;(b);  // 成功转换Base* b2 = new Base();Derived* d2 = dynamic_cast&lt;Derived*&gt;(b2); // 返回nullptr\n\n前提条件：基类至少包含一个虚函数（多态类型）\n六、协变返回类型（Covariant Return Types）class Base &#123;public:    virtual Base* clone() const &#123;        return new Base(*this);    &#125;&#125;;class Derived : public Base &#123;public:    // 返回类型可以是派生类指针    virtual Derived* clone() const override &#123;        return new Derived(*this);    &#125;&#125;;\n\n应用实践：虚拟机制的高级用法1. 工厂模式（Factory Pattern）class Product &#123;public:    virtual void operation() = 0;    virtual ~Product() &#123;&#125;&#125;;class Creator &#123;public:    virtual Product* createProduct() = 0;    virtual ~Creator() &#123;&#125;&#125;;class ConcreteCreator : public Creator &#123;public:    Product* createProduct() override &#123;        return new ConcreteProduct();    &#125;&#125;;\n\n2. 访问者模式（Visitor Pattern）class Element &#123;public:    virtual void accept(Visitor&amp; v) = 0;    virtual ~Element() &#123;&#125;&#125;;class Visitor &#123;public:    virtual void visit(ElementA&amp;) = 0;    virtual void visit(ElementB&amp;) = 0;    virtual ~Visitor() &#123;&#125;&#125;;\n\n3. 策略模式（Strategy Pattern）class SortingStrategy &#123;public:    virtual void sort(vector&lt;int&gt;&amp;) const = 0;    virtual ~SortingStrategy() &#123;&#125;&#125;;class QuickSort : public SortingStrategy &#123; /*...*/ &#125;;class MergeSort : public SortingStrategy &#123; /*...*/ &#125;;// 运行时切换策略context.setStrategy(new QuickSort());\n\n性能分析与优化虚函数开销来源\n\n\n开销类型\n说明\n典型值\n\n\n\n间接调用开销\n虚函数表查找\n1-3个时钟周期\n\n\n缓存不友好\nvptr导致缓存失效\n视情况而定\n\n\n代码膨胀\n虚表存储空间\n每类4-8字节+虚表大小\n\n\n内联限制\n虚函数无法内联\n关键路径损失大\n\n\n优化策略\n虚函数缓存：对频繁调用的虚函数结果缓存\n模板+CRTP：编译期多态替代运行时多态template &lt;typename T&gt;class Base &#123;    void interface() &#123;        static_cast&lt;T*&gt;(this)-&gt;implementation();    &#125;&#125;;class Derived : public Base&lt;Derived&gt; &#123;    void implementation();&#125;;\nfinal类优化：标记不需要进一步继承的类class Leaf final : public Base &#123;    // 编译器可去虚化&#125;;\n\n\n总结：虚拟机制的最佳实践核心原则\n虚析构规则：多态基类必须声明虚析构函数\n接口清晰化：使用override明确重写关系\n抽象约束：不应实例化的类声明纯虚函数\n继承控制：合理使用final限制继承链\nRTTI节制：避免过度依赖dynamic_cast\n\n应用场景决策树graph TDA[需要运行时多态？] --是--&gt; B[需要接口约束？]A --否--&gt; C[使用模板/静态多态]B --是--&gt; D[定义抽象类]B --否--&gt; E[使用普通虚函数]D --&gt; F[派生类实现接口]E --&gt; G[注意虚析构函数]\n\nC++11&#x2F;14&#x2F;17增强特性\n\n\n特性\n版本\n作用\n\n\n\noverride\nC++11\n明确重写关系\n\n\nfinal\nC++11\n禁止重写&#x2F;继承\n\n\n委托构造函数\nC++11\n简化构造链\n\n\n继承构造函数\nC++11\n提升代码复用\n\n\n[[nodiscard]]\nC++17\n虚函数返回值检查\n\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"另外一个类Unix系统 —— FreeBSD","url":"/2024/10/01/41.freebsd/","content":"前言这里只是简单介绍freebsd系统由来、发展、应用以及快速上手freeBSD系统\n\n一、总述FreeBSD 是一个开源、高性能的类 Unix 操作系统，以其卓越的稳定性、先进的网络功能和强大的文件系统著称。源自著名的 BSD UNIX，它已成为服务器、网络设备和存储系统的首选平台。本文全面解析 FreeBSD 的历史渊源、发展脉络、核心应用场景，并提供新手快速入门指南。\n\n二、由来：从伯克利到开源1. BSD Unix 起源 (1977-1993)\n伯克利实验室：加州大学伯克利分校在 AT&amp;T UNIX 基础上开发了 BSD 系统\n里程碑贡献：创造了 TCP&#x2F;IP 协议栈、vi 编辑器、C Shell 等核心技术\n法律转折：1993 年发布完全开源的 4.4BSD-Lite，清除 AT&amp;T 专利代码\n\n2. FreeBSD 诞生 (1993)\n创始团队：Jordan Hubbard、Nate Williams 和 Rod Grimes\n首次发布：1993 年 11 月推出 FreeBSD 1.0\n核心目标：为 x86 平台提供易用且功能完整的 BSD 系统\n\n\n三、发展：从成熟到创新1. 奠基时期 (1993-1999)\n1.x&#x2F;2.x 系列：专注硬件兼容性和基础优化\n早期创新：引入 ports 软件管理系统雏形\n\n2. 黄金时代 (1999-2008)\n4.x 系列：被誉为”互联网的隐形引擎”\n突破性技术：GEOM 存储框架、softupdates 文件系统优化\n应用场景：驱动 Yahoo!、Netflix 等早期互联网巨头\n\n\n\n3. 现代化演进 (2008 至今)\n\n\n版本\n重大创新\n技术影响\n\n\n\n7.x\nZFS 文件系统、DTrace 动态追踪\n存储和诊断革命\n\n\n8&#x2F;9.x\nbhyve 虚拟化、Capsicum 安全框架\n云和安全增强\n\n\n10&#x2F;11x\npkg 包管理、Linux 二进制兼容\n易用性和兼容性提升\n\n\n12&#x2F;13x\nWireGuard VPN、OpenZFS 加密\n网络与安全强化\n\n\n14x\nbhyve 图形支持、LLVM 工具链升级\n虚拟化和开发现代化\n\n\n\n四、核心应用方向1. 服务器领域\n网络服务器：全球 30%+ CDN 节点基于 FreeBSD（据 Netflix 统计）\n存储系统：ZFS 提供企业级数据完整性（iXsystems TrueNAS 核心）\n数据库平台：PostgreSQL 官方推荐运行环境\n\n2. 网络基础设施\n防火墙&#x2F;路由器：pf 防火墙效率超 Linux iptables 40%（BSD Magazine 测试）\nVPN 网关：原生支持 IPsec&#x2F;OpenVPN&#x2F;WireGuard\n负载均衡器：haproxy 最佳运行平台之一\n\n3. 新兴技术领域\n云原生：bhyve 虚拟化 + Kubernetes 支持\n物联网：轻量级 NanoBSD 版本（&lt;128MB 存储）\n嵌入式系统：ARM64 成为 Tier-1 架构（路由器&#x2F;交换机）\n\n\n五、快速上手指南1. 系统安装# 推荐新手选择镜像站下载https://download.freebsd.org/ftp/releases/ISO-IMAGES/14.0/# 安装要点：1. 分区时启用 ZFS 可获得最佳体验2. 配置网络时开启 SSH 服务3. 选择安装 &quot;lib32&quot; 兼容库支持 Linux 应用\n\n2. 基础命令速查\n\n\n功能\n命令\n说明\n\n\n\n包管理\npkg install nano\n安装软件包\n\n\n\npkg upgrade\n更新所有软件\n\n\n系统更新\nfreebsd-update fetch\n获取系统更新\n\n\n\nfreebsd-update install\n安装系统更新\n\n\n服务管理\nservice sshd start\n启动 SSH 服务\n\n\n\nservice nginx restart\n重启 Web 服务\n\n\n网络配置\nifconfig vtnet0\n查看网卡信息\n\n\n\nping google.com\n测试网络连通性\n\n\n文件操作\nzfs list\n查看 ZFS 存储池\n\n\n\nzfs snapshot tank/data@backup\n创建快照\n\n\n3. 新手必做配置# 1. 添加用户到 wheel 组获取 sudo 权限pw usermod username -G wheel# 2. 启用 Linux 兼容层（支持运行 Linux 应用）sysrc linux_enable=&quot;YES&quot;service linux start# 3. 配置 pkg 加速镜像（中国用户）mkdir -p /usr/local/etc/pkg/reposecho &#x27;FreeBSD: &#123; url: &quot;pkg+https://mirrors.ustc.edu.cn/freebsd-pkg/$&#123;ABI&#125;&quot; &#125;&#x27; &gt; /usr/local/etc/pkg/repos/FreeBSD.conf# 4. 安装基础工具pkg install bash git neofetch\n\n\n六、总结FreeBSD 历经 30 年发展，已从学术研究系统演变为：\n\n技术领先：ZFS&#x2F;bhyve&#x2F;DTrace 等创新持续引领行业\n场景多元：从超算中心到嵌入式设备的全栈支持\n生态完善：30,000+ 软件包覆盖主流应用需求\n\n新手建议：从 VirtualBox 虚拟机体验开始，优先掌握：\n\nZFS 快照管理 (zfs snapshot&#x2F;zfs rollback)\nJail 容器技术 (iocage create)\n网络配置 (rc.conf 管理)\n定期更新 (freebsd-update + pkg upgrade)\n\n\n官方资源推荐：\n\n手册：https://docs.freebsd.org/en/books/handbook/\n论坛：https://forums.freebsd.org/\n软件搜索：https://freshports.org/\n\n\n\n","categories":["FreeBSD"],"tags":["OS"]},{"title":"rust语言知识点汇总","url":"/2024/11/03/42.rust/","content":"前言这里只是简单列出Rsut语言的知识点\n\n一、基础语法1.1 变量与可变性let x = 5;          // 不可变绑定let mut y = 10;     // 可变绑定y = 15;             // 允许修改const MAX: u32 = 100; // 常量\n\n1.2 数据类型\n\n\n类型\n说明\n示例\n\n\n\n标量类型\n单个值\ni32, f64, bool, char\n\n\n复合类型\n多个值\ntuple, array\n\n\n自定义类型\n用户定义\nstruct, enum\n\n\n// 元组let tup: (i32, f64, u8) = (500, 6.4, 1);let (x, y, z) = tup; // 解构// 数组let a = [1, 2, 3, 4, 5];let first = a[0]; // 1\n\n二、控制流2.1 条件语句let number = 6;if number % 4 == 0 &#123;    println!(&quot;divisible by 4&quot;);&#125; else if number % 2 == 0 &#123;    println!(&quot;divisible by 2&quot;);&#125; else &#123;    println!(&quot;not divisible by 4 or 2&quot;);&#125;// if表达式let condition = true;let num = if condition &#123; 5 &#125; else &#123; 6 &#125;;\n\n2.2 循环// loop循环let mut count = 0;loop &#123;    count += 1;    if count == 3 &#123;        break;    &#125;&#125;// while循环let mut num = 3;while num != 0 &#123;    println!(&quot;&#123;num&#125;!&quot;);    num -= 1;&#125;// for循环let a = [10, 20, 30, 40, 50];for element in a &#123;    println!(&quot;the value is: &#123;element&#125;&quot;);&#125;\n\n三、函数3.1 函数定义fn add(x: i32, y: i32) -&gt; i32 &#123;    x + y  // 隐式返回（无分号）&#125;fn main() &#123;    let sum = add(5, 3);    println!(&quot;Sum: &#123;sum&#125;&quot;);&#125;\n\n3.2 闭包let add_one = |x| x + 1;println!(&quot;5 + 1 = &#123;&#125;&quot;, add_one(5));// 捕获环境let y = 10;let add_y = |x| x + y;println!(&quot;5 + 10 = &#123;&#125;&quot;, add_y(5));\n\n四、所有权系统（Rust核心特性）4.1 所有权规则\nRust中每个值都有一个所有者\n一次只能有一个所有者\n当所有者离开作用域，值将被丢弃\n\n4.2 移动语义let s1 = String::from(&quot;hello&quot;);let s2 = s1; // s1的所有权移动到s2// println!(&quot;&#123;s1&#125;&quot;); // 错误！s1不再有效\n\n4.3 克隆let s1 = String::from(&quot;hello&quot;);let s2 = s1.clone(); // 深拷贝println!(&quot;s1 = &#123;s1&#125;, s2 = &#123;s2&#125;&quot;); // 都有效\n\n4.4 借用let s = String::from(&quot;hello&quot;);// 不可变引用let len = calculate_length(&amp;s);// 可变引用let mut s = String::from(&quot;hello&quot;);change(&amp;mut s);fn calculate_length(s: &amp;String) -&gt; usize &#123;    s.len()&#125;fn change(some_string: &amp;mut String) &#123;    some_string.push_str(&quot;, world&quot;);&#125;\n\n4.5 生命周期fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;    if x.len() &gt; y.len() &#123;        x    &#125; else &#123;        y    &#125;&#125;\n\n五、结构体与枚举5.1 结构体struct User &#123;    username: String,    email: String,    sign_in_count: u64,    active: bool,&#125;let user1 = User &#123;    email: String::from(&quot;user@example.com&quot;),    username: String::from(&quot;someusername123&quot;),    active: true,    sign_in_count: 1,&#125;;// 方法impl User &#123;    fn display(&amp;self) &#123;        println!(&quot;User: &#123;&#125;&quot;, self.username);    &#125;&#125;\n\n5.2 枚举enum IpAddr &#123;    V4(u8, u8, u8, u8),    V6(String),&#125;let home = IpAddr::V4(127, 0, 0, 1);let loopback = IpAddr::V6(String::from(&quot;::1&quot;));// Option枚举let some_number = Some(5);let absent_number: Option&lt;i32&gt; = None;\n\n六、模式匹配6.1 match表达式let coin = Coin::Quarter(UsState::Alaska);let value = match coin &#123;    Coin::Penny =&gt; 1,    Coin::Nickel =&gt; 5,    Coin::Dime =&gt; 10,    Coin::Quarter(state) =&gt; &#123;        println!(&quot;State quarter from &#123;:?&#125;!&quot;, state);        25    &#125;,&#125;;\n\n6.2 if let语法糖let some_value = Some(3);// 等价于 match some_value &#123; Some(3) =&gt; ..., _ =&gt; () &#125;if let Some(3) = some_value &#123;    println!(&quot;three&quot;);&#125;\n\n七、错误处理7.1 panic! 宏fn main() &#123;    panic!(&quot;crash and burn&quot;);&#125;\n\n7.2 Result 枚举use std::fs::File;let f = File::open(&quot;hello.txt&quot;);let f = match f &#123;    Ok(file) =&gt; file,    Err(error) =&gt; panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, error),&#125;;// ?运算符fn read_username() -&gt; Result&lt;String, io::Error&gt; &#123;    let mut s = String::new();    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;    Ok(s)&#125;\n\n八、泛型与Trait8.1 泛型struct Point&lt;T&gt; &#123;    x: T,    y: T,&#125;impl&lt;T&gt; Point&lt;T&gt; &#123;    fn x(&amp;self) -&gt; &amp;T &#123;        &amp;self.x    &#125;&#125;let integer = Point &#123; x: 5, y: 10 &#125;;let float = Point &#123; x: 1.0, y: 4.0 &#125;;\n\n8.2 Traitpub trait Summary &#123;    fn summarize(&amp;self) -&gt; String;&#125;pub struct NewsArticle &#123;    pub headline: String,    pub location: String,    pub author: String,    pub content: String,&#125;impl Summary for NewsArticle &#123;    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.headline, self.author, self.location)    &#125;&#125;\n\n九、智能指针9.1 Boxlet b = Box::new(5);println!(&quot;b = &#123;&#125;&quot;, b); // 5\n\n9.2 Rc（引用计数）use std::rc::Rc;let a = Rc::new(5);let b = Rc::clone(&amp;a);\n\n9.3 RefCell（内部可变性）use std::cell::RefCell;let cell = RefCell::new(5);*cell.borrow_mut() = 10;println!(&quot;&#123;&#125;&quot;, *cell.borrow()); // 10\n\n十、并发编程10.1 线程use std::thread;let handle = thread::spawn(|| &#123;    for i in 1..10 &#123;        println!(&quot;hi number &#123;i&#125; from the spawned thread!&quot;);    &#125;&#125;);for i in 1..5 &#123;    println!(&quot;hi number &#123;i&#125; from the main thread!&quot;);&#125;handle.join().unwrap();\n\n10.2 通道use std::sync::mpsc;let (tx, rx) = mpsc::channel();thread::spawn(move || &#123;    let val = String::from(&quot;hi&quot;);    tx.send(val).unwrap();&#125;);let received = rx.recv().unwrap();println!(&quot;Got: &#123;&#125;&quot;, received);\n\n10.3 Mutexuse std::sync::&#123;Arc, Mutex&#125;;let counter = Arc::new(Mutex::new(0));let mut handles = vec![];for _ in 0..10 &#123;    let counter = Arc::clone(&amp;counter);    let handle = thread::spawn(move || &#123;        let mut num = counter.lock().unwrap();        *num += 1;    &#125;);    handles.push(handle);&#125;for handle in handles &#123;    handle.join().unwrap();&#125;println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());\n\n十一、常用集合11.1 Vectorlet mut v: Vec&lt;i32&gt; = Vec::new();v.push(1);v.push(2);let third: &amp;i32 = &amp;v[2];println!(&quot;The third element is &#123;third&#125;&quot;);for i in &amp;mut v &#123;    *i += 50;&#125;\n\n11.2 Stringlet mut s = String::from(&quot;foo&quot;);s.push_str(&quot;bar&quot;);let s2 = &quot;baz&quot;.to_string();let s3 = s + &amp;s2; // s的所有权被移动\n\n11.3 HashMapuse std::collections::HashMap;let mut scores = HashMap::new();scores.insert(String::from(&quot;Blue&quot;), 10);scores.insert(String::from(&quot;Yellow&quot;), 50);for (key, value) in &amp;scores &#123;    println!(&quot;&#123;key&#125;: &#123;value&#125;&quot;);&#125;\n\n十二、模块系统12.1 模块定义mod front_of_house &#123;    pub mod hosting &#123;        pub fn add_to_waitlist() &#123;&#125;    &#125;&#125;pub use crate::front_of_house::hosting;pub fn eat_at_restaurant() &#123;    hosting::add_to_waitlist();&#125;\n\n12.2 文件结构restaurant├── Cargo.toml└── src    ├── lib.rs    └── front_of_house.rs\n\n十三、Cargo与包管理13.1 Cargo.toml[package]name = &quot;my_project&quot;version = &quot;0.1.0&quot;edition = &quot;2021&quot;[dependencies]rand = &quot;0.8.5&quot;\n\n13.2 常用命令cargo new my_project   # 创建新项目cargo build            # 编译项目cargo run              # 编译并运行cargo test             # 运行测试cargo doc --open       # 生成并打开文档\n\n十四、最佳实践\n所有权优先：理解并合理使用所有权系统\n错误处理：优先使用Result而非panic!\n类型安全：充分利用Rust的类型系统\n并发安全：使用Arc&#x2F;Mutex等安全并发原语\n零成本抽象：合理使用泛型和trait\n测试驱动：编写单元测试和集成测试\n文档注释：使用&#x2F;&#x2F;&#x2F;编写文档注释\n模式匹配：充分利用match和if let\n避免unsafe：只在必要时使用unsafe代码\n性能优化：理解Rust的内存模型进行优化\n\n\nRust是一种系统编程语言，专注于安全、并发和性能。它通过所有权系统在编译期保证内存安全，无需垃圾回收。Rust适合系统编程、WebAssembly、嵌入式系统和高性能服务端应用等场景。\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"类Unix系统的对比","url":"/2025/01/03/44.OS/","content":"前言这里只是简单对比两大类unix操作系统\n\n一、概述1.1 FreeBSDFreeBSD 是开源的类Unix操作系统，源自 BSD (Berkeley Software Distribution)。它是完整的操作系统，包含内核、驱动程序和用户空间工具：\n\n核心特点：ZFS文件系统、Jail容器、DTrace工具\n许可证：BSD许可证（允许商业闭源使用）\n应用场景：网络服务器、存储系统、嵌入式设备\n代表项目：Netflix CDN、Sony PlayStation 4&#x2F;5系统\n\n1.2 LinuxLinux 是开源的类Unix操作系统内核，需配合GNU工具链构成完整OS：\n\n核心特点：多样化发行版、广泛硬件支持、庞大社区\n许可证：GPL许可证（要求衍生作品开源）\n应用场景：云计算、超级计算机、桌面系统、物联网\n代表发行版：Ubuntu、CentOS、Debian、Arch\n\n\n二、核心对比\n\n\n对比维度\nFreeBSD\nLinux\n\n\n\n架构类型\n完整操作系统\n内核+发行版组合\n\n\n许可证\nBSD许可证（允许闭源）\nGPL许可证（要求开源）\n\n\n文件系统\nZFS原生支持，UFS默认\nEXT4&#x2F;XFS&#x2F;Btrfs，ZFS需额外安装\n\n\n网络栈\n高性能原生网络栈（适合高负载）\n多样化实现（不同发行版有差异）\n\n\n包管理\npkg二进制包 + Ports源码编译\nAPT&#x2F;YUM&#x2F;DNF&#x2F;Pacman等（发行版专属）\n\n\n容器技术\nJail（轻量级原生隔离）\nDocker&#x2F;LXC&#x2F;Podman\n\n\n硬件支持\n相对有限（专注服务器硬件）\n广泛支持（包含最新消费级硬件）\n\n\n开发语言\nC语言主导\n多样化（C&#x2F;C++&#x2F;Rust&#x2F;Go）\n\n\n更新策略\n整体更新（内核与用户空间同步）\n内核与用户空间独立更新\n\n\n\n三、软件安装对比3.1 FreeBSD 软件管理二进制安装 (pkg)# 搜索软件pkg search nginx# 安装软件pkg install nginx# 更新系统pkg update &amp;&amp; pkg upgrade\n\n源码编译 (Ports)# 进入ports目录cd /usr/ports/www/nginx# 编译安装make install clean# 定制编译选项make config\n\n3.2 Linux 软件管理Debian&#x2F;Ubuntu (APT)apt updateapt install nginxapt upgrade\n\nRHEL&#x2F;CentOS (DNF&#x2F;YUM)dnf updatednf install nginxdnf upgrade\n\nArch Linux (Pacman)pacman -Syupacman -S nginx\n\n\n四、硬件要求对比4.1 FreeBSD 硬件要求\n\n\n设备类型\n最低要求\n推荐要求\n\n\n\nCPU\ni486兼容处理器\n多核64位处理器\n\n\n内存\n512MB\n4GB+（ZFS需额外内存）\n\n\n存储\n10GB硬盘空间\nSSD + 50GB+（ZFS推荐）\n\n\n网络\n百兆网卡\n千兆&#x2F;万兆网卡\n\n\n显卡\n文本模式无需显卡\n桌面环境需兼容显卡\n\n\n特殊支持：\n\n服务器级硬件（Intel&#x2F;AMD企业级CPU）\nZFS需要ECC内存防止数据损坏\n网络加速卡（Intel IXGBE驱动）\n\n4.2 Linux 硬件要求\n\n\n设备类型\n最低要求\n推荐要求\n\n\n\nCPU\ni686兼容处理器\n多核64位处理器\n\n\n内存\n1GB（桌面） &#x2F; 512MB（服务器）\n4GB+（桌面） &#x2F; 2GB+（服务器）\n\n\n存储\n10GB硬盘空间\nSSD + 50GB+\n\n\n网络\n百兆网卡\n千兆&#x2F;万兆网卡\n\n\n显卡\n文本模式无需显卡\n桌面环境需专用驱动\n\n\n特殊支持：\n\n广泛硬件兼容（包括ARM&#x2F;RISC-V）\n最新消费级硬件（NVIDIA&#x2F;AMD显卡）\n虚拟化扩展（VT-x&#x2F;AMD-V）\n\n\n五、性能对比（典型场景）\n\n\n场景\nFreeBSD优势\nLinux优势\n\n\n\n网络吞吐\n更高TCP性能（尤其小包处理）\n灵活配置（XDP&#x2F;eBPF优化）\n\n\n文件服务\nZFS原生支持（数据完整性保障）\nEXT4&#x2F;XFS成熟稳定\n\n\n虚拟化\nJail轻量级（低开销）\nKVM&#x2F;Docker生态完善\n\n\n安全隔离\nCapsicum能力模型（细粒度控制）\nSELinux&#x2F;AppArmor成熟方案\n\n\n实时性\n一般\nPREEMPT_RT实时内核补丁\n\n\n能源管理\n基础支持\n更优笔记本&#x2F;移动设备支持\n\n\n\n六、适用场景建议6.1 推荐使用 FreeBSD\n企业级存储系统：ZFS文件系统提供高级数据管理\n\n# 创建ZFS存储池zpool create tank mirror /dev/ada1 /dev/ada2zfs create tank/databases\n\n高负载网络设备：防火墙&#x2F;路由器（PF防火墙）\n\n# PF防火墙规则示例pass in on $ext_if proto tcp to port &#123; 80, 443 &#125;block in quick from &lt;malicious_ips&gt;\n\n特定应用服务器：流媒体服务（Netflix优化方案）\n法律敏感环境：BSD许可证允许闭源修改\n\n6.2 推荐使用 Linux\n云计算平台：KVM虚拟化 + Kubernetes生态\n科研计算：GPU加速&#x2F;AI框架支持\n桌面环境：GNOME&#x2F;KDE等成熟桌面\n嵌入式设备：多样化ARM支持\n前沿硬件：最新显卡&#x2F;外设驱动\n\n\n七、迁移注意事项\n\n\n迁移方向\n关键挑战\n解决方案\n\n\n\nLinux → FreeBSD\n1. 系统管理命令差异2. 硬件驱动缺失3. 软件包名称不同\n1. 学习BSD命令（如ifconfig→ifconfig）2. 验证硬件兼容性3. 使用pkg替代apt&#x2F;yum\n\n\nFreeBSD → Linux\n1. ZFS移植困难2. Jail迁移复杂3. 网络配置差异\n1. 改用Btrfs&#x2F;ZFSonLinux2. 转换为Docker&#x2F;LXC3. 适应NetworkManager\n\n\n\n八、总结\n\n\n核心选择建议\n\n\n\n\n选择FreeBSD\n• 需要ZFS高级存储功能• 构建高性能网络服务• 法律要求宽松的许可证• 使用Jail轻量级隔离\n\n\n选择Linux\n• 需要广泛硬件支持• 使用前沿开发技术（如eBPF）• 部署云原生应用• 需要丰富桌面环境\n\n\n\n混合架构建议：大型基础设施可同时使用两者，如：\n\nFreeBSD 作为存储后端（ZFS优势）\nLinux 作为计算节点（容器化优势）\n\n\n学习资源：\n\nFreeBSD手册：https://docs.freebsd.org/en/books/handbook/\nLinux文档项目：https://tldp.org/\n跨平台管理工具：Ansible&#x2F;SaltStack（统一管理BSD&#x2F;Linux）\n\n\n","categories":["OS"],"tags":["OS"]},{"title":"OSI七层模型","url":"/2025/02/12/45.net/","content":"前言这里只是简单梳理OSI七层模型\n\n一、总述OSI（Open Systems Interconnection）七层模型是国际标准化组织（ISO）设计的网络通信概念框架，它将网络通信过程分解为七个逻辑层次。该模型的核心价值在于：\n\n� 分层解耦：各层功能独立，便于协议设计与故障排查\n🌐 标准化：提供通用语言促进跨厂商设备互操作性\n🔍 教学工具：系统化理解网络通信全流程\n\n\n模型虽非实际协议标准，但已成为网络工程师的核心思维框架，实际应用如TCP&#x2F;IP协议簇也基于此模型简化而来\n\n\n二、分层详解（自底向上）1. 物理层（Physical Layer）核心角度：  \n\n🧲 功能本质：通过物理介质传输原始比特流（0&#x2F;1）  \n🔌 设备视角：网卡、中继器、集线器、传输介质（光纤&#x2F;双绞线）  \n📊 数据单元：比特（Bit）  \n🌰 实例解析：  graph LRA[计算机] -- 电压变化 --&gt; B[双绞线] -- 光脉冲 --&gt; C[光纤]\n\n2. 数据链路层（Data Link Layer）多维度分析：\n\n🔒 功能核心：\n物理寻址（MAC地址）\n差错检测（CRC校验）\n流量控制（滑动窗口）\n\n\n🚦 协议视角：以太网（Ethernet）、PPP、帧中继\n🧩 PDU：帧（Frame）\n⚠️ 安全风险：MAC地址欺骗、ARP欺骗攻击\n\n3. 网络层（Network Layer）关键视角对比：  \n\n\n\n功能维度\n实现机制\n典型设备\n\n\n\n逻辑寻址\nIP地址分配（IPv4&#x2F;v6）\n路由器\n\n\n路径选择\n路由协议（OSPF&#x2F;BGP）\n三层交换机\n\n\n数据分片重组\nIP分片与重组机制\n-\n\n\n\n🧩 PDU：数据包（Packet）\n\n4. 传输层（Transport Layer）核心功能矩阵：\npie    title 传输层协议对比    “TCP” ： 70    “UDP” ： 30\n\n🔁 TCP特性：\n面向连接（三次握手）\n可靠传输（ACK确认&#x2F;重传）\n流量控制（滑动窗口）\n\n\n🚀 UDP特性：\n无连接\n低延迟\n适用于视频流&#x2F; DNS查询\n\n\n🧩 PDU：段（Segment）\n\n5. 会话层（Session Layer）独特价值：\n\n🤝 对话控制：建立&#x2F;维护&#x2F;终止会话（如RPC调用）\n🔄 同步点：网络故障后从检查点恢复传输\n⚠️ 实际应用：\nWindows NT的NetBIOS\nSSH会话保持\n\n\n💡 认知误区：在TCP&#x2F;IP模型中常被合并到传输层\n\n6. 表示层（Presentation Layer）跨领域视角：\n\n🔣 数据转换：\n编码转换（ASCII ↔ Unicode）\n数据结构化（JSON&#x2F;XML解析）\n\n\n🔐 安全网关：\n加密&#x2F;解密（SSL&#x2F;TLS初始处理）\n压缩解压（gzip算法）\n\n\n🌰 实例：Web服务器将EBCDIC转换为ASCII码\n\n7. 应用层（Application Layer）服务视角：  \n\n\n\n服务类型\n协议簇\n端口范围\n\n\n\n文件传输\nFTP&#x2F;SFTP\n20-21&#x2F;22\n\n\n网页访问\nHTTP&#x2F;HTTPS\n80&#x2F;443\n\n\n邮件服务\nSMTP&#x2F;POP3&#x2F;IMAP\n25&#x2F;110&#x2F;143\n\n\n域名解析\nDNS\n53\n\n\n\n🧩 PDU：报文（Message）\n\n\n三、多角度综合分析1. 数据封装流程graph TBA[原始数据] --&gt; B[应用层加头] --&gt; C[表示层加头] --&gt; D[会话层加头] --&gt; E[传输层加头] --&gt; F[网络层加头] --&gt; G[数据链路层加头尾] --&gt; H[物理层比特流]\n\n2. 典型通信场景分析网页访问流程：\n\n应用层：浏览器生成HTTP请求\n传输层：TCP分段（源端口随机，目的端口80）\n网络层：IP封装（源IP→目标IP）\n数据链路层：以太网帧封装（源MAC→网关MAC）\n物理层：电信号传输\n\n3. 安全威胁分布\n\n\n层级\n典型攻击方式\n防御措施\n\n\n\n应用层\nSQL注入、XSS跨站脚本\nWAF防火墙\n\n\n传输层\nSYN洪水攻击\nSYN Cookie\n\n\n网络层\nIP欺骗、DDoS\nACL访问控制\n\n\n数据链路层\nARP欺骗、MAC泛洪\n端口安全、DAI检测\n\n\n4. OSI vs TCP&#x2F;IP模型graph LR  OSI七层 --&gt; TCP/IP四层  应用层 --&gt; 应用层  表示层 --&gt; 应用层  会话层 --&gt; 应用层  传输层 --&gt; 传输层  网络层 --&gt; 网络层  数据链路层 --&gt; 网络接口层  物理层 --&gt; 网络接口层\n关键差异：\n\nTCP&#x2F;IP更注重实用性，OSI更强调理论完整性\nTCP&#x2F;IP将上三层合并为应用层\nOSI严格定义层间服务接口，TCP&#x2F;IP更灵活\n\n\n四、总结OSI模型的核心价值\n教学基石：系统化理解网络通信全貌的最佳框架\n排错指南：分层定位故障（如物理层检查线路→网络层检查路由）\n协议设计：指导新协议开发定位（如QUIC协议定位传输层）\n跨平台交互：提供异构系统互操作的理论基础\n\n\n现代意义：尽管实际网络中TCP&#x2F;IP占据主导地位，但OSI七层模型仍然是：\n\n网络认证考试的核心内容（如CCNA&#x2F;HCIA）\n网络设备设计的逻辑框架\n解决复杂网络问题的思维工具\n\n\n\n","categories":["network"],"tags":["Lan"]},{"title":"使用宝塔面板高效管理你的VPS","url":"/2024/12/09/43.%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/","content":"前言这里只是简单介绍宝塔面板\n\n一、宝塔面板概述1.1 什么是宝塔面板宝塔面板（BT Panel）是一款国产开源、简单高效的服务器运维管理面板，支持Linux和Windows服务器。它通过Web界面提供了：\n\n服务器资源监控\n网站管理\n数据库管理\nFTP管理\n文件管理\n安全管理等一站式解决方案\n\n1.2 核心优势\n\n\n优势\n说明\n\n\n\n可视化操作\n无需记忆复杂命令，图形化界面操作\n\n\n高效部署\n一键部署LNMP&#x2F;LAMP环境\n\n\n安全防护\n内置防火墙、防篡改、监控告警\n\n\n免费开源\n基础功能完全免费，源码开放\n\n\n多环境支持\n支持PHP多版本共存、Python&#x2F;Node.js环境\n\n\n1.3 适用场景\n个人开发者：快速搭建个人网站&#x2F;博客\n中小企业：高效管理多个网站项目\n运维人员：批量管理服务器资源\n教育机构：服务器运维教学工具\n\n\n二、安装与配置2.1 系统要求\n\n\n项目\n最低要求\n推荐配置\n\n\n\nCPU\n1核\n2核+\n\n\n内存\n1GB\n2GB+\n\n\n硬盘\n10GB\n20GB+\n\n\n系统\nCentOS 7+&#x2F;Ubuntu 18+&#x2F;Debian 9+\nCentOS 8\n\n\n2.2 安装步骤# Linux一键安装脚本if [ -f /usr/bin/curl ];then curl -sSO https://download.bt.cn/install/install_panel.sh;else wget -O install_panel.sh https://download.bt.cn/install/install_panel.sh;fibash install_panel.sh ed8484bec# Windows安装1. 访问官网下载Windows安装包2. 双击运行宝塔安装程序3. 按提示完成安装\n\n安装完成后：\n\n访问 http://服务器IP:8888\n输入安装时显示的初始账号密码\n首次登录需绑定宝塔账号（需注册）\n\n2.3 安全配置1. **修改默认端口**：   - 面板设置 → 安全设置 → 修改面板端口（如修改为：8080）2. **设置安全入口**：   - 添加访问路径后缀（如：`/bt_secret`）3. **配置防火墙**：   - 仅开放必要端口（80,443,SSH端口）   - 禁用root远程登录   - 开启BasicAuth认证\n\n\n三、核心功能详解3.1 网站管理1. **创建网站**：   - 域名：输入主域名（支持多个）   - 根目录：设置网站文件存储路径   - PHP版本：选择PHP版本（支持多版本共存）   - 数据库：自动创建MySQL数据库   - FTP：可选创建FTP账户2. **SSL证书**：   - Let&#x27;s Encrypt免费证书一键申请   - 支持手动上传证书   - 自动续签功能3. **伪静态规则**：   - 内置WordPress/Discuz等常用规则   - 支持自定义规则\n\n3.2 数据库管理\n\n\n功能\n说明\n\n\n\nphpMyAdmin\n网页版MySQL管理工具\n\n\n远程访问\n开启数据库远程连接\n\n\n备份策略\n定时自动备份数据库\n\n\n性能优化\n一键调整配置参数\n\n\n权限管理\n精细控制用户权限\n\n\n3.3 文件管理- **在线编辑器**：支持代码高亮、批量编辑- **压缩解压**：ZIP/TAR/GZ格式支持- **远程下载**：通过URL直接下载文件- **权限设置**：可视化修改文件权限- **回收站**：防止误删文件\n\n3.4 应用商店\n\n\n分类\n常见应用\n\n\n\n运行环境\nNginx&#x2F;Tomcat&#x2F;PM2\n\n\n开发工具\nGitLab&#x2F;Jenkins&#x2F;SVN\n\n\n网站程序\nWordPress&#x2F;Discuz&#x2F;Typecho\n\n\n企业应用\n企业邮局&#x2F;ERP&#x2F;OA系统\n\n\n安全防护\n防火墙&#x2F;防篡改&#x2F;木马查杀\n\n\n3.5 监控与安全1. **实时监控**：   - CPU/内存/磁盘IO/网络流量   - 进程资源占用排行2. **安全防护**：   - SSH登录告警   - 恶意请求拦截   - 网站防篡改程序   - 木马扫描工具3. **计划任务**：   - 定时备份（网站/数据库）   - 日志切割   - 释放内存   - 自定义Shell脚本\n\n四、实战操作指南4.1 部署WordPress网站1. 【软件商店】→ 一键部署 → 选择WordPress2. 填写域名、数据库名、用户名密码3. 访问域名完成WordPress安装4. 【网站】→ 设置 → SSL → 申请Let&#x27;s Encrypt证书5. 开启HTTPS强制跳转\n\n4.2 配置服务器防火墙1. 【安全】→ 防火墙 → 添加放行端口（80,443,SSH端口）2. 设置禁止PING3. 开启CC攻击防护4. 设置IP黑名单（屏蔽恶意IP）\n\n4.3 数据库自动备份1. 【计划任务】→ 添加任务2. 类型：备份数据库3. 周期：每天凌晨3点4. 保留最新：3份5. 备份到：云存储（阿里云OSS/腾讯云COS）\n\n\n五、常见问题解决方案5.1 常见问题排查\n\n\n问题\n解决方案\n\n\n\n无法访问面板\n检查防火墙&#x2F;安全组是否开放端口\n\n\n网站502错误\nPHP服务未启动 → 重启PHP服务\n\n\n数据库连接失败\n检查数据库权限&#x2F;root密码是否更改\n\n\n磁盘空间不足\n清理日志文件（&#x2F;www&#x2F;server&#x2F;data）\n\n\nHTTPS不生效\n检查443端口开放&#x2F;证书是否绑定\n\n\n5.2 常用命令# 宝塔面板管理bt 1   # 停止面板bt 2   # 启动面板bt 14  # 显示面板默认信息# 服务管理/etc/init.d/nginx restart   # 重启Nginx/etc/init.d/mysqld restart  # 重启MySQL/etc/init.d/pure-ftpd restart # 重启FTP\n\n六、进阶使用技巧6.1 多服务器管理1. 安装【宝塔云端运维】插件2. 添加多台服务器3. 统一监控所有服务器状态4. 批量执行命令/部署应用\n\n6.2 API接口开发import requestsurl = &quot;http://面板地址:端口/install?action=get_site_types&quot;headers = &#123;&quot;Authorization&quot;: &quot;Bearer API密钥&quot;&#125;response = requests.get(url, headers=headers)print(response.json())  # 获取支持的网站类型\n\n6.3 自定义插件开发1. 创建插件目录：/www/server/panel/plugin/2. 编写插件结构：   ├── plugin.json    # 插件配置   ├── index.html     # 前端页面   └── __init__.py    # 后端逻辑3. 通过宝塔开发者平台提交审核\n\n七、宝塔面板优缺点7.1 优点\n零门槛操作：无需Linux命令基础\n生态丰富：超过100个免费插件\n高效部署：环境安装速度提升10倍+\n持续更新：平均每月发布新版本\n社区支持：活跃中文社区&#x2F;论坛\n\n7.2 缺点\n资源占用：约占用200MB内存\n依赖绑定：部分功能需绑定宝塔账号\n学习曲线：高级功能仍需Linux知识\n安全风险：面板本身可能成为攻击入口\n\n\n八、最佳实践建议\n安全加固：\n\n定期修改面板密码\n开启双重认证\n限制面板访问IP\n\n\n资源优化：\n\n关闭未使用的服务\n配置SWAP虚拟内存\n定期清理日志文件\n\n\n备份策略：\n\n本地 + 云端双重备份\n每月测试备份恢复\n关键配置手动备份\n\n\n版本管理：\n\n生产环境不立即更新新版本\n测试环境先行验证\n关注官方安全公告\n\n\n\n\n宝塔面板官网：https://www.bt.cn宝塔论坛：https://www.bt.cn/bbs开源地址：https://github.com/aaPanel\n\n通过合理使用宝塔面板，运维效率可提升70%以上，特别适合中小型项目的快速部署与管理。\n\n","categories":["Sever"],"tags":["Cloud"]},{"title":"VScode装上插件，直接起飞","url":"/2025/03/03/46.VScode/","content":"前言这里是简单分享一下我自己在使用VScode高效插件\n–\nVSCode高效开发插件推荐一、通用效率工具\n\n\n插件名\n功能亮点\n推荐指数\n\n\n\nGitLens\n代码行级Git历史追溯、作者标注、提交分析\n⭐⭐⭐⭐⭐\n\n\nTodo Tree\n自动扫描//TODO注释生成可视化任务树\n⭐⭐⭐⭐\n\n\nError Lens\n行内实时高亮错误提示（替代传统底部状态栏）\n⭐⭐⭐⭐\n\n\nProject Manager\n快速切换项目&#x2F;标记重要文件夹\n⭐⭐⭐⭐\n\n\n二、代码智能增强\n\n\n插件名\n适用场景\n核心技术\n\n\n\nGitHub Copilot\nAI全栈代码补全（需订阅）\nOpenAI Codex\n\n\nTabnine\n本地化AI补全（免费版够用）\n本地ML模型\n\n\nCode Spell Checker\n变量名拼写检查\n字典匹配\n\n\nImport Cost\n实时显示npm包体积\nWebpack分析\n\n\n三、前端开发套件graph LRA[语言支持] --&gt; B[Lint工具] --&gt; C[框架扩展] --&gt; D[可视化工具]\n\n基础支持：\nESLint - JavaScript&#x2F;TS规范检查\nPrettier - 自动化代码格式化\nAuto Rename Tag - 联动修改HTML&#x2F;XML标签\n\n\n框架扩展：\nVolar - Vue 3终极支持（替代Vetur）\nReact Refactor - JSX组件快速重构\n\n\n可视化工具：\nCSS Peek - 从HTML跳转CSS定义\nImage preview - 悬浮预览图片路径\n\n\n\n四、后端&#x2F;全栈开发\n\n\n类型\n插件\n关键能力\n\n\n\nAPI调试\nThunder Client\nPostman替代品（轻量级）\n\n\n数据库\nSQLTools\n多数据库连接+查询界面\n\n\nDocker\nDocker\n容器管理+镜像构建\n\n\n部署\nRemote - SSH\n远程服务器开发\n\n\n五、UI&#x2F;交互优化- **主题管理**：  - `One Dark Pro` - 最受欢迎暗色主题  - `Material Icon Theme` - 文件图标美化- **动画增强**：  - `Power Mode` - 打字粒子特效（谨慎开启）  - `Rainbow CSV` - CSV文件列彩色分栏- **排版辅助**：  - `Indent Rainbow` - 缩进层级彩色标识  - `Bracket Pair Colorizer` - 括号配对高亮\n\n六、避坑指南\n插件冲突：避免同时安装同类插件（如Vetur和Volar）\n性能黑洞：慎用实时渲染类插件（如某些Markdown预览工具）\n必备配置（settings.json）：&#123;  &quot;extensions.autoUpdate&quot;: true,  &quot;extensions.ignoreRecommendations&quot;: false,  &quot;workbench.startupEditor&quot;: &quot;none&quot; // 启动不打开欢迎页&#125;\n\n黄金法则：插件数量控制在15个以内，定期用Extension Profiler检测性能影响\n\n\n\n终极推荐组合方案pie    title 开发者类型推荐配置    “前端” ： 40    “全栈” ： 35    “后端/Python” ： 15    “Java” ： 10\n\n前端标配：GitLens + Prettier + Volar + CSS Peek\n全栈利器：Remote-SSH + Docker + Thunder Client + SQLTools\n极简主义：仅装GitLens + Copilot（保持编辑器纯净）\n\n提示：通过Ctrl+Shift+X打开扩展商店，搜索插件名一键安装。安装后建议重启VSCode生效\n\n","categories":["Tools"],"tags":["tool"]},{"title":"pyQt对比Qt","url":"/2025/05/03/48.QT%E4%B8%8EPYQT/","content":"前言在跨平台GUI开发领域，Qt和PyQt是两个至关重要的框架，这里只是简单区分PyQT和QT\n\n一、总体概述Qt 是由Qt Company开发的跨平台C++应用程序框架，不仅包含GUI工具包，还提供了网络、数据库、多媒体等综合解决方案。而PyQt 是Riverbank Computing开发的Python绑定库，允许开发者在Python中使用Qt框架的功能。\n简言之：Qt是基础框架(C++)，PyQt是其在Python中的接口。两者关系类似汽车发动机与方向盘——Qt提供核心动力，PyQt让Python开发者能够驾驭这个强大的引擎。\ngraph LR    A[Qt Framework] --&gt;|C++ 原生实现| B[核心功能]    B --&gt; C[GUI模块]    B --&gt; D[网络模块]    B --&gt; E[数据库模块]    F[PyQt] --&gt;|Python 绑定| A    F --&gt; G[Python开发者接口]\n\n二、核心区别详解1. 语言基础与运行环境\n\n\n特性\nQt\nPyQt\n\n\n\n编程语言\nC++\nPython\n\n\n执行方式\n编译型（机器码）\n解释型（字节码）\n\n\n运行时依赖\nQt动态库\nPython+Qt动态库\n\n\n典型应用场景\n高性能桌面&#x2F;嵌入式\n快速开发&#x2F;脚本工具\n\n\n关键差异：Qt应用经过编译后可直接运行，PyQt需要Python解释器环境。这导致Qt应用性能更高（特别是图形密集型应用），而PyQt开发迭代更快。\n2. 授权协议对比pie    title 授权协议分布    “Qt (LGPL/GPL)” ： 45    “Qt 商业授权” ： 30    “PyQt (GPL)” ： 20    “PyQt 商业授权” ： 5\n\n\nQt：提供双重授权\n\n开源版：LGPLv3&#x2F;GPLv3\n商业版：需购买许可证（闭源开发友好）\n\n\nPyQt：\n\n默认采用GPLv3（要求开源衍生作品）\n商业使用需购买Riverbank的商业许可\n\n\n\n重要影响：商业闭源项目使用PyQt时需特别注意授权合规性，而Qt的商业授权选项更灵活。\n3. 开发体验对比Qt开发流程 (C++)：\n#include &lt;QApplication&gt;#include &lt;QLabel&gt;int main(int argc, char *argv[]) &#123;    QApplication app(argc, argv);    QLabel label(&quot;Hello Qt!&quot;);    label.show();    return app.exec();&#125;// 需使用qmake/cmake编译\n\nPyQt开发流程 (Python)：\nimport sysfrom PyQt5.QtWidgets import QApplication, QLabelapp = QApplication(sys.argv)label = QLabel(&quot;Hello PyQt!&quot;)label.show()sys.exit(app.exec_())# 直接运行无需编译\n\n效率差异：\n\n调试速度：PyQt支持实时修改+运行（REPL环境）\n开发周期：PyQt项目通常比Qt快30%-50%\n部署复杂度：Qt打包简单（单一可执行文件），PyQt需处理Python环境\n\n4. 性能关键指标\n\n\n测试项\nQt (C++)\nPyQt (Python)\n差距\n\n\n\n窗口启动时间\n120ms\n350ms\n2.9x\n\n\n万行表格渲染\n220ms\n980ms\n4.5x\n\n\n3D图形帧率\n60 FPS\n28 FPS\n53%↓\n\n\n结论：在CPU密集型任务和图形渲染方面，原生Qt性能显著优于PyQt。但对普通表单应用，差异不易察觉。\n5. 工具链支持共享工具：\n\nQt Designer（可视化UI设计）\nQMake&#x2F;CMake（项目构建）\nQt Linguist（国际化支持）\n\n独有优势：\n\nQt：深度集成的Qt Creator IDE\nPyQt：可结合PyCharm&#x2F;VSCode等Python生态工具\n\n工作流区别：\n\nQt开发：在Qt Creator中完成编码-设计-调试全流程\nPyQt开发：通常用Python IDE写逻辑 + Qt Designer设计界面\n\n\n三、如何选择：决策指南✅ 选择Qt(C++)的场景：\n开发性能敏感的桌面&#x2F;嵌入式应用（如CAD、视频编辑）\n需要闭源分发的商业软件\n已有C++技术栈的团队\n目标平台资源受限（如ARM设备）\n\n✅ 选择PyQt的场景：\n快速开发业务工具&#x2F;内部系统\n与Python科学计算栈集成（NumPy&#x2F;Pandas）\n需要AI功能集成（PyTorch&#x2F;TensorFlow）\n开发周期紧张的MVP产品\n\n\n四、总结：互补的兄弟框架Qt和PyQt本质是同一技术栈的不同呈现方式：\n\nQt 是高性能基石：适合系统级开发，提供原生跨平台能力\nPyQt 是效率加速器：降低Qt使用门槛，释放Python开发潜力\n\n\n","categories":["Program Language"],"tags":["Language knowledge"]},{"title":"优雅的使用python获取网站上的文字","url":"/2025/04/15/47.chrome_txt/","content":"前言这里简单分享一个获取网页上文字的python小脚本\n\n实现思路graph TDA[启动程序] --&gt; B[发送HTTP请求获取网页]B --&gt; C[解析HTML提取文本]C --&gt; D[清洗处理文本数据]D --&gt; E[存储到SQLite数据库]E --&gt; F[输出执行结果]\n\n分块实现1. 导入依赖库import requests  # 发送HTTP请求获取网页内容from bs4 import BeautifulSoup  # 解析HTML文档import sqlite3  # 轻量级数据库操作import re  # 正则表达式用于文本清洗\n\n2. 网页请求模块def fetch_webpage(url):    &quot;&quot;&quot;    获取网页HTML内容    :param url: 目标网页URL    :return: 网页HTML文本    &quot;&quot;&quot;    headers = &#123;        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;    &#125;  # 模拟浏览器请求头，避免被网站屏蔽        try:        response = requests.get(url, headers=headers, timeout=10)  # 设置10秒超时        response.raise_for_status()  # 检查HTTP状态码，非200抛出异常        response.encoding = response.apparent_encoding  # 自动识别网页编码        return response.text  # 返回网页HTML内容    except requests.exceptions.RequestException as e:        print(f&quot;网页请求失败: &#123;e&#125;&quot;)        return None  # 请求失败返回空值\n\n3. 内容解析模块def extract_text_content(html):    &quot;&quot;&quot;    从HTML中提取并清洗文本内容    :param html: 网页HTML文本    :return: 清洗后的纯文本字符串    &quot;&quot;&quot;    if not html:        return &quot;&quot;  # 空HTML返回空文本        soup = BeautifulSoup(html, &#x27;html.parser&#x27;)  # 创建BeautifulSoup解析对象        # 移除不需要的标签（脚本、样式等）    for element in soup([&#x27;script&#x27;, &#x27;style&#x27;, &#x27;header&#x27;, &#x27;footer&#x27;, &#x27;nav&#x27;]):        element.decompose()  # 彻底移除这些标签及其内容        # 获取所有段落文本    paragraphs = soup.find_all([&#x27;p&#x27;, &#x27;h1&#x27;, &#x27;h2&#x27;, &#x27;h3&#x27;, &#x27;h4&#x27;, &#x27;h5&#x27;, &#x27;h6&#x27;])    raw_text = &#x27; &#x27;.join([p.get_text().strip() for p in paragraphs])  # 拼接所有文本        # 文本清洗处理    cleaned_text = re.sub(r&#x27;\\s+&#x27;, &#x27; &#x27;, raw_text)  # 合并多余空格    cleaned_text = re.sub(r&#x27;[^\\w\\s.,;:!?\\&#x27;&quot;-]&#x27;, &#x27;&#x27;, cleaned_text)  # 移除非文字字符        return cleaned_text[:5000]  # 返回前5000个字符（避免过长）\n\n4. 数据库存储模块def setup_database():    &quot;&quot;&quot;    创建SQLite数据库和表结构    :return: 数据库连接对象    &quot;&quot;&quot;    conn = sqlite3.connect(&#x27;web_content.db&#x27;)  # 创建或连接数据库文件    cursor = conn.cursor()  # 获取数据库游标        # 创建数据表（如果不存在）    cursor.execute(&#x27;&#x27;&#x27;        CREATE TABLE IF NOT EXISTS scraped_data (            id INTEGER PRIMARY KEY AUTOINCREMENT,            url TEXT NOT NULL UNIQUE,  -- 网页URL（唯一）            content TEXT,             -- 网页文本内容            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP        )    &#x27;&#x27;&#x27;)  # 包含ID、URL、内容和时间戳的表结构        conn.commit()  # 提交表结构变更    return conn  # 返回数据库连接def save_to_database(conn, url, content):    &quot;&quot;&quot;    将数据存储到数据库    :param conn: 数据库连接对象    :param url: 网页URL    :param content: 文本内容    &quot;&quot;&quot;    cursor = conn.cursor()    try:        # 插入或替换已有URL的数据        cursor.execute(&#x27;&#x27;&#x27;            INSERT OR REPLACE INTO scraped_data (url, content)            VALUES (?, ?)        &#x27;&#x27;&#x27;, (url, content))  # 使用参数化查询防止SQL注入        conn.commit()  # 提交事务        print(f&quot;数据存储成功: &#123;url&#125;&quot;)    except sqlite3.Error as e:        print(f&quot;数据库操作失败: &#123;e&#125;&quot;)\n\n5. 主流程控制def main():    &quot;&quot;&quot;主执行函数&quot;&quot;&quot;    target_url = &quot;https://example.com/article&quot;  # 替换为目标网站URL        print(&quot;=&quot;*50)    print(&quot;网页爬虫程序启动&quot;)    print(&quot;=&quot;*50)        # 1. 初始化数据库    db_connection = setup_database()    print(&quot;数据库初始化完成&quot;)        # 2. 获取网页内容    print(f&quot;正在抓取: &#123;target_url&#125;&quot;)    html_content = fetch_webpage(target_url)        if html_content:        # 3. 解析文本内容        print(&quot;解析网页内容...&quot;)        text_content = extract_text_content(html_content)                if text_content:            # 4. 存储到数据库            print(f&quot;获取到&#123;len(text_content)&#125;字符的文本&quot;)            save_to_database(db_connection, target_url, text_content)        else:            print(&quot;未提取到有效文本内容&quot;)    else:        print(&quot;网页获取失败，请检查URL或网络连接&quot;)        # 5. 关闭数据库连接    db_connection.close()    print(&quot;数据库连接已关闭&quot;)    print(&quot;=&quot;*50)    print(&quot;程序执行完毕&quot;)if __name__ == &quot;__main__&quot;:    main()  # 程序入口\n\n使用说明执行流程\n安装依赖库：pip install requests beautifulsoup4\n将脚本中的target_url替换为实际目标网址\n运行脚本：python web_scraper.py\n查看生成的web_content.db数据库文件\n\n示例输出==================================================网页爬虫程序启动==================================================数据库初始化完成正在抓取: https://example.com/article解析网页内容...获取到2487字符的文本数据存储成功: https://example.com/article数据库连接已关闭==================================================程序执行完毕\n\n数据库查询使用SQLite客户端执行：\nSELECT url, LENGTH(content) AS char_count, timestamp FROM scraped_data;\n\n\n总结技术要点总结\n\n\n模块\n关键技术\n注意事项\n\n\n\n网页请求\nRequests库\n需设置User-Agent和超时\n\n\n内容解析\nBeautifulSoup\n注意标签清理和编码处理\n\n\n文本清洗\n正则表达式\n保留关键标点符号\n\n\n数据存储\nSQLite3\n使用参数化查询防注入\n\n\n扩展建议\n增加异常处理：添加重试机制应对网络波动\n遵守robots.txt：检查目标网站的爬虫协议\n添加延时：在循环爬取时使用time.sleep()避免被封\n数据去重：使用MD5校验内容哈希值\n扩展功能：\n添加命令行参数支持\n实现多页爬取\n导出CSV&#x2F;Excel格式\n\n\n\n\n法律声明：实际使用前请确保遵守目标网站的robots.txt协议和相关法律法规，本示例仅用于技术学习目的。大规模商业爬取需获得网站授权。\n\n","categories":["Projects"],"tags":["chrome"]},{"title":"pyQt项目之图书管理系统","url":"/2025/05/12/49.pyQT_book_manager_system/","content":"前言这里简单分享一个使用pyQT写一个图书管理系统，并给出思路以及用到的工具，每个模块得到源码\n\n系统设计思路graph TDA[主界面] --&gt; B[数据库模块]A --&gt; C[图书管理模块]C --&gt; D[添加图书]C --&gt; E[删除图书]C --&gt; F[修改图书]C --&gt; G[查询图书]A --&gt; H[表格展示模块]B --&gt; I[SQLite数据库]\n\n功能模块划分\n数据库模块：负责数据库连接和图书数据操作\n主界面模块：构建GUI界面和布局\n图书管理模块：实现增删改查业务逻辑\n表格展示模块：使用QTableView展示图书数据\n\n\n分块实现1. 导入依赖库import sysimport sqlite3from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,                             QTableView, QPushButton, QLineEdit, QLabel, QMessageBox, QHeaderView)from PyQt5.QtGui import QStandardItemModel, QStandardItemfrom PyQt5.QtCore import Qt\n\n2. 数据库模块class BookDatabase:    def __init__(self, db_name=&quot;library.db&quot;):        &quot;&quot;&quot;初始化数据库连接&quot;&quot;&quot;        self.conn = sqlite3.connect(db_name)  # 连接SQLite数据库        self.create_table()  # 创建数据表            def create_table(self):        &quot;&quot;&quot;创建图书数据表&quot;&quot;&quot;        cursor = self.conn.cursor()        cursor.execute(&#x27;&#x27;&#x27;            CREATE TABLE IF NOT EXISTS books (                id INTEGER PRIMARY KEY AUTOINCREMENT,                title TEXT NOT NULL,                author TEXT NOT NULL,                isbn TEXT UNIQUE,                publish_year INTEGER,                quantity INTEGER DEFAULT 0            )        &#x27;&#x27;&#x27;)  # 图书表包含ID、书名、作者、ISBN、出版年份和数量字段        self.conn.commit()            def add_book(self, title, author, isbn, year, quantity):        &quot;&quot;&quot;添加新图书&quot;&quot;&quot;        cursor = self.conn.cursor()        try:            cursor.execute(&#x27;&#x27;&#x27;                INSERT INTO books (title, author, isbn, publish_year, quantity)                VALUES (?, ?, ?, ?, ?)            &#x27;&#x27;&#x27;, (title, author, isbn, year, quantity))            self.conn.commit()            return True        except sqlite3.IntegrityError:            return False  # ISBN重复时返回False                def delete_book(self, book_id):        &quot;&quot;&quot;根据ID删除图书&quot;&quot;&quot;        cursor = self.conn.cursor()        cursor.execute(&quot;DELETE FROM books WHERE id = ?&quot;, (book_id,))        self.conn.commit()        return cursor.rowcount &gt; 0  # 返回是否成功删除            def update_book(self, book_id, title, author, isbn, year, quantity):        &quot;&quot;&quot;更新图书信息&quot;&quot;&quot;        cursor = self.conn.cursor()        cursor.execute(&#x27;&#x27;&#x27;            UPDATE books             SET title=?, author=?, isbn=?, publish_year=?, quantity=?            WHERE id=?        &#x27;&#x27;&#x27;, (title, author, isbn, year, quantity, book_id))        self.conn.commit()        return cursor.rowcount &gt; 0  # 返回是否成功更新            def search_books(self, keyword=&quot;&quot;):        &quot;&quot;&quot;搜索图书（支持模糊查询）&quot;&quot;&quot;        cursor = self.conn.cursor()        # 使用SQL LIKE实现模糊搜索        query = &#x27;&#x27;&#x27;            SELECT * FROM books             WHERE title LIKE ? OR author LIKE ? OR isbn LIKE ?        &#x27;&#x27;&#x27;        cursor.execute(query, (f&quot;%&#123;keyword&#125;%&quot;, f&quot;%&#123;keyword&#125;%&quot;, f&quot;%&#123;keyword&#125;%&quot;))        return cursor.fetchall()  # 返回所有匹配结果            def get_all_books(self):        &quot;&quot;&quot;获取所有图书&quot;&quot;&quot;        cursor = self.conn.cursor()        cursor.execute(&quot;SELECT * FROM books ORDER BY title&quot;)        return cursor.fetchall()            def close(self):        &quot;&quot;&quot;关闭数据库连接&quot;&quot;&quot;        self.conn.close()\n\n3. 主界面类class LibraryApp(QMainWindow):    def __init__(self):        super().__init__()        self.setWindowTitle(&quot;图书管理系统&quot;)  # 设置窗口标题        self.resize(800, 600)  # 设置初始窗口大小                # 初始化数据库        self.db = BookDatabase()                # 创建中央部件和布局        central_widget = QWidget()        self.setCentralWidget(central_widget)        main_layout = QVBoxLayout()        central_widget.setLayout(main_layout)                # 创建搜索区域        search_layout = QHBoxLayout()        self.search_input = QLineEdit()        self.search_input.setPlaceholderText(&quot;输入书名、作者或ISBN...&quot;)        search_button = QPushButton(&quot;搜索&quot;)        search_button.clicked.connect(self.search_books)        search_layout.addWidget(self.search_input)        search_layout.addWidget(search_button)        main_layout.addLayout(search_layout)                # 创建表格视图        self.table_view = QTableView()        self.table_model = QStandardItemModel()  # 创建数据模型        self.setup_table()  # 初始化表格        main_layout.addWidget(self.table_view)                # 创建按钮区域        button_layout = QHBoxLayout()        self.add_button = QPushButton(&quot;添加图书&quot;)        self.edit_button = QPushButton(&quot;修改图书&quot;)        self.delete_button = QPushButton(&quot;删除图书&quot;)        self.refresh_button = QPushButton(&quot;刷新列表&quot;)                # 连接按钮信号        self.add_button.clicked.connect(self.show_add_dialog)        self.edit_button.clicked.connect(self.show_edit_dialog)        self.delete_button.clicked.connect(self.delete_book)        self.refresh_button.clicked.connect(self.load_books)                button_layout.addWidget(self.add_button)        button_layout.addWidget(self.edit_button)        button_layout.addWidget(self.delete_button)        button_layout.addWidget(self.refresh_button)        main_layout.addLayout(button_layout)                # 加载图书数据        self.load_books()            def setup_table(self):        &quot;&quot;&quot;配置表格视图&quot;&quot;&quot;        self.table_model.setHorizontalHeaderLabels(            [&quot;ID&quot;, &quot;书名&quot;, &quot;作者&quot;, &quot;ISBN&quot;, &quot;出版年份&quot;, &quot;数量&quot;]        )        self.table_view.setModel(self.table_model)                # 设置表格属性        self.table_view.setSelectionBehavior(QTableView.SelectRows)  # 整行选择        self.table_view.setEditTriggers(QTableView.NoEditTriggers)  # 禁止直接编辑        self.table_view.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)  # 自动拉伸列宽            def load_books(self):        &quot;&quot;&quot;加载所有图书到表格&quot;&quot;&quot;        self.table_model.removeRows(0, self.table_model.rowCount())  # 清空现有数据        books = self.db.get_all_books()                for book in books:            row = [                QStandardItem(str(book[0])),  # ID                QStandardItem(book[1]),       # 书名                QStandardItem(book[2]),       # 作者                QStandardItem(book[3]),       # ISBN                QStandardItem(str(book[4])),   # 出版年份                QStandardItem(str(book[5]))    # 数量            ]            self.table_model.appendRow(row)                def search_books(self):        &quot;&quot;&quot;搜索图书并刷新表格&quot;&quot;&quot;        keyword = self.search_input.text().strip()        books = self.db.search_books(keyword)        self.table_model.removeRows(0, self.table_model.rowCount())                for book in books:            row = [                QStandardItem(str(book[0])),                QStandardItem(book[1]),                QStandardItem(book[2]),                QStandardItem(book[3]),                QStandardItem(str(book[4])),                QStandardItem(str(book[5]))            ]            self.table_model.appendRow(row)        def get_selected_book_id(self):        &quot;&quot;&quot;获取当前选中图书的ID&quot;&quot;&quot;        selected = self.table_view.selectionModel().selectedRows()        if selected:            index = selected[0].row()            return int(self.table_model.item(index, 0).text())  # 获取ID列的值        return None        def show_add_dialog(self):        &quot;&quot;&quot;显示添加图书对话框&quot;&quot;&quot;        dialog = BookDialog(self)        if dialog.exec_() == BookDialog.Accepted:            # 获取对话框中的数据            data = dialog.get_data()            success = self.db.add_book(*data)                        if success:                QMessageBox.information(self, &quot;成功&quot;, &quot;图书添加成功！&quot;)                self.load_books()  # 刷新列表            else:                QMessageBox.warning(self, &quot;错误&quot;, &quot;添加失败：ISBN已存在！&quot;)        def show_edit_dialog(self):        &quot;&quot;&quot;显示编辑图书对话框&quot;&quot;&quot;        book_id = self.get_selected_book_id()        if not book_id:            QMessageBox.warning(self, &quot;警告&quot;, &quot;请先选择要编辑的图书&quot;)            return                    # 获取图书当前信息        book = self.get_book_by_id(book_id)        if not book:            return                    dialog = BookDialog(self, edit_mode=True)        dialog.set_data(book)  # 填充当前数据                if dialog.exec_() == BookDialog.Accepted:            data = dialog.get_data()            # 更新数据（跳过ID）            success = self.db.update_book(book_id, *data)                        if success:                QMessageBox.information(self, &quot;成功&quot;, &quot;图书信息更新成功！&quot;)                self.load_books()            else:                QMessageBox.warning(self, &quot;错误&quot;, &quot;更新失败，请检查数据&quot;)        def delete_book(self):        &quot;&quot;&quot;删除选中图书&quot;&quot;&quot;        book_id = self.get_selected_book_id()        if not book_id:            QMessageBox.warning(self, &quot;警告&quot;, &quot;请先选择要删除的图书&quot;)            return                    reply = QMessageBox.question(            self, &quot;确认删除&quot;,            &quot;确定要删除这本图书吗？此操作不可恢复！&quot;,            QMessageBox.Yes | QMessageBox.No        )                if reply == QMessageBox.Yes:            success = self.db.delete_book(book_id)            if success:                QMessageBox.information(self, &quot;成功&quot;, &quot;图书已删除&quot;)                self.load_books()            else:                QMessageBox.warning(self, &quot;错误&quot;, &quot;删除失败，图书不存在&quot;)        def get_book_by_id(self, book_id):        &quot;&quot;&quot;根据ID获取图书详细信息&quot;&quot;&quot;        cursor = self.db.conn.cursor()        cursor.execute(&quot;SELECT * FROM books WHERE id=?&quot;, (book_id,))        return cursor.fetchone()        def closeEvent(self, event):        &quot;&quot;&quot;重写关闭事件，确保关闭数据库连接&quot;&quot;&quot;        self.db.close()        event.accept()\n\n4. 图书对话框类（用于添加&#x2F;编辑）class BookDialog(QDialog):    def __init__(self, parent=None, edit_mode=False):        super().__init__(parent)        self.setWindowTitle(&quot;编辑图书&quot; if edit_mode else &quot;添加图书&quot;)        self.setFixedSize(400, 300)                layout = QVBoxLayout()        self.setLayout(layout)                # 创建表单字段        form_layout = QFormLayout()                self.title_input = QLineEdit()        self.author_input = QLineEdit()        self.isbn_input = QLineEdit()        self.year_input = QLineEdit()        self.quantity_input = QLineEdit()                # 设置输入验证        self.year_input.setValidator(QIntValidator(1000, 2100, self))  # 年份范围        self.quantity_input.setValidator(QIntValidator(0, 999, self))  # 数量范围                form_layout.addRow(&quot;书名*:&quot;, self.title_input)        form_layout.addRow(&quot;作者*:&quot;, self.author_input)        form_layout.addRow(&quot;ISBN*:&quot;, self.isbn_input)        form_layout.addRow(&quot;出版年份:&quot;, self.year_input)        form_layout.addRow(&quot;数量:&quot;, self.quantity_input)                layout.addLayout(form_layout)                # 创建按钮        button_box = QDialogButtonBox(            QDialogButtonBox.Ok | QDialogButtonBox.Cancel        )        button_box.accepted.connect(self.validate)        button_box.rejected.connect(self.reject)                layout.addWidget(button_box)        def validate(self):        &quot;&quot;&quot;验证表单数据&quot;&quot;&quot;        title = self.title_input.text().strip()        author = self.author_input.text().strip()        isbn = self.isbn_input.text().strip()                if not title or not author or not isbn:            QMessageBox.warning(self, &quot;输入错误&quot;, &quot;带*号的字段不能为空&quot;)            return                    self.accept()  # 所有验证通过，关闭对话框        def get_data(self):        &quot;&quot;&quot;获取表单数据&quot;&quot;&quot;        return (            self.title_input.text().strip(),            self.author_input.text().strip(),            self.isbn_input.text().strip(),            int(self.year_input.text() or 0),            int(self.quantity_input.text() or 0)        )        def set_data(self, book_data):        &quot;&quot;&quot;填充表单数据（编辑模式）&quot;&quot;&quot;        # book_data格式: (id, title, author, isbn, year, quantity)        self.title_input.setText(book_data[1])        self.author_input.setText(book_data[2])        self.isbn_input.setText(book_data[3])        self.year_input.setText(str(book_data[4]))        self.quantity_input.setText(str(book_data[5]))\n\n5. 应用启动if __name__ == &quot;__main__&quot;:    app = QApplication(sys.argv)    window = LibraryApp()    window.show()    sys.exit(app.exec_())\n\n\n使用指南功能说明\n添加图书：点击”添加图书”按钮，填写必填信息（书名、作者、ISBN）\n修改图书：选中图书后点击”修改图书”，编辑信息\n删除图书：选中图书后点击”删除图书”，确认删除\n搜索功能：在搜索框输入关键词，支持书名&#x2F;作者&#x2F;ISBN模糊匹配\n刷新列表：点击”刷新列表”按钮重置显示\n\n安装与运行\n安装依赖：\n\npip install pyqt5 sqlite3\n\n\n运行程序：\n\npython library_app.py\n\n\n初始界面：\n\n+-----------------------------------------+| 图书管理系统                             ||-----------------------------------------|| [搜索框] [搜索按钮]                      ||-----------------------------------------|| ID | 书名 | 作者 | ISBN | 年份 | 数量    ||-----------------------------------------|| ...（图书列表）...                      ||-----------------------------------------|| [添加] [修改] [删除] [刷新]              |+-----------------------------------------+\n\n总结技术要点总结\n\n\n模块\n关键技术\n实现说明\n\n\n\n数据库\nSQLite3\n轻量级嵌入式数据库\n\n\nUI框架\nPyQt5\n跨平台GUI开发框架\n\n\n数据展示\nQTableView + QStandardItemModel\nModel-View架构\n\n\n数据验证\nQValidator\n输入内容验证\n\n\n对话框\nQDialog\n模态对话框交互\n\n\n扩展建议\n用户认证：添加登录系统，区分管理员和普通用户\n借阅管理：扩展借阅记录功能，添加读者表\n数据导入导出：支持Excel&#x2F;CSV格式导入导出\n报表生成：添加借阅统计、库存报表\n多语言支持：使用Qt翻译系统实现国际化\n主题切换：添加暗色&#x2F;亮色模式切换\n\n\n","categories":["Projects"],"tags":["chrome"]},{"title":"四周年 - 特别篇","url":"/2025/06/06/50.year4/","content":"【我的小窝也四岁了】亲爱的网站：四载春秋，你从青涩代码长成承载无数思绪的港湾。感谢你收录我的成长碎片，连接陌生的共鸣。未来，愿我们继续做彼此的星光，不惧岁月漫长。\n生日快乐！曦曦小窝2025年6月6日\n","categories":["特别篇"],"tags":["Anniversary"]},{"title":"让你的Windows和mac一样优雅","url":"/2021/10/18/5.Windows%20Dynamic%20Desktop/","content":"前言我这里是Windows10&#x2F;11专业工作版(其他Windows版本也适用)如果你的设备是已经是结束支持的Windows7，系统主题的操作变化操作可能不太适用mac桌面Apple 在macOS Mojave(10.14) 推出深色和浅色的壁纸出现，经过macOS Catalina(10.15)、macOS Big Sur(11) 的发展，macOS的壁纸成了动态变化的壁纸，这些壁纸可以随着时间的变化。在一天中自行从浅色变为深色。主题也会变化。Windows桌面需要做到这样的操作，我会介绍一个简单的下工具 Windows Dynamic Desktop（以下简称 WinDD）\nWinDD介绍WinDD 是一个 开源项目，由开发者t1m0thyj创建，旨在为 Windows 用户提供类似于 macOS Mojave 的动态桌面体验。 该项目模仿了自然环境中的光照变化，使你的桌面背景根据一天中实际的时间自动调整. 从而带来更为沉浸和真实的交互感觉。 此项目的实现依赖于以下几个关键的技术点：图像处理 WinDD 可以处理多张不同光照条件下的桌面壁纸，并按照时间进行平滑过渡。\n下载WinDD由于WinDD是一个开源项目，这里就直接给出官网下载链接Github下载Github\n按照自己的系统规格来下载适合自己的软件也可以通过Microsoft store下载微软应用商店Micosoft Store\n安装WinDD点击安装文件要选择安装语言（这里是没有简体正文的）选择安装位置安装就一直下一步就好好啦！！！\n设置WinDD首次打开Windd，会设置语言,这里我们以简体中文就好了接下来就会调整我们的壁纸修改时间了，选择 “使用Windows定位服务确定的时间”打开程序，下载你要设置的主题然后在程序中选择你夏欢的的壁纸，如果不喜欢，那么可以去他的官方主题上下载(部分付费)\nhttps://windd.info/themes/\n\nWindows主题现在我们来解决Windows主题深色，浅色转化,会使用到一个工具 Auto Dark Mode(以下简称ADM)\nADM介绍Auto Dark Mode 是一款可以为 Windows 提供自动深色模式的系统主题软件，可以根据不同规则（时间、电量、应用）自动切换深色模式或浅色模式。在调整模式的同时甚至还可以自动切换桌面壁纸，而且 Auto Dark Mode 完全免费， 在微软应用商店可以下载。微软应用商店Micosoft Store开源网站下载链接Github安装就一直下一步就好好啦！！！\n设置ADM打开ADM把 Enable Automatic Thame Switching (启用主题切换)打开然后，打开之后选择第二个 From sunset to sunrise（location service）就会出现完成了让两个程序（WinDD 和 ADM）一直运行下去就好了（占用资源极少）结语1、安装WinDD2、设置WinDD的语言3、下载WinDD的动态壁纸4、安装ADM5、将ADM的时间设置为自己的本机定位时间","categories":["美化"],"tags":["Windows Dynamic Desktop"]},{"title":"在macOS上优雅安装homebrew","url":"/2021/11/16/6.homebrew/","content":"前言我这里是macOS Catalina（10.15），如果是macOS 11（big sur） 和 macOS 12（Monterey）也适用。老版本的macOS有些不被支持，请查阅相关文档homebrew是什么Homebrew官网：英文：https://brew.sh中文：https://brew.sh/index_zh-cnHomebrew是MacOS（或 Linux）的软件包管理器。通过它，我们可以方便的对Mac上的各种应用软件进行管理，例如：安装、更新、查看、搜索、卸载等。Homebrew，可谓是Mac神器，几乎每一位Mac使用者都会安装它。用Homebrew官网的一句话总结：Homebrew 使 macOS（或您的 Linux 系统）更完整。安装homebrew打开终端在启动台中点击终端，点击打开终端\n输入指令在终端命令行窗口输入安装命令。这里需要特别说明几点内容。下面是Homebrew官方给出的安装命令：（如果没有魔法网络，不要使用此命令安装！）\n/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;\n通常情况下，官网给出的指令会报错：curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused因为这是国外网站，由于GFW（中国长城防火墙）的存在，如果没有vpn，是无法访问的，所以连接被拒绝！\n使用国内源安装代码指令以下为国内安装Homebrew的正确姿势：(基于gitee上某个大佬的自动安装脚本)\n/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;\n回车执行指令后，根据提示操作。具体包括以下提示操作：\n选择下载镜像有个源1、中科大下载源2、清华大学下载源3、北京外国语大学下载源4、腾讯下载源（不推荐）5、阿里巴巴下载源（不推荐 缺少 cask源）根据需要选择下载源，例如，我这里选择中科大下载源，就输入‘1’，回车。\n确认删除旧版本如果存在旧版本，会弹出删除旧版本提示，输入”Y”，回车。\n输入开机密码（用于mac确认第三方应用安装）安装git如果之前没有安装过git，会终止homebrew安装，弹出git安装提示，点击“安装”。\n再次执行homebrew安装指令耐心等待git安装完成后，再次运行homebrew安装指令，重新根据提示操作即可。安装需要一段时间，过程中，可以在终端看到脚本执行了那些操作。\n验证是否安装成功安装脚本执行完成后，重启终端。（重启后才生效）通过在终端输入”brew -v”，可以查看homebrew版本。如果正确输出版本信息，表示成功安装\nbrew -v\n\nHomebrew卸载如需卸载homebrew，请执行语句：\n/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)&quot;\n\n总结1、打开终端2、输入代码，推荐使用国内源的代码3、验证是否安装成功4、卸载homebrew","categories":["tool"],"tags":["homebrew"]},{"title":"在macOS上两行命令配置好Node和Git","url":"/2021/12/26/7.node/","content":"前言我这里是macOS Catalina（10.15），如果是macOS 11（big sur） 和 macOS 12（Monterey）也适用。老版本的macOS有些不被支持，请查阅相关文档Node.js什么是noode.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I&#x2F;O 的模型，使其轻量又高效。简单的说 Node.js 就是运行在服务端的 JavaScript，利用JavaScript在服务端进行编程。Node.js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby平起平坐。Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js使用JavaScript进行编程，运行在JavaScript引擎上（V8）。nodejs开发的构成就成利用npm开发的社区提供的大量的第三方包加上基本的ECMAScript脚本语言以及node平台提供的一系列编程接口进行编程。\n代码安装Node.js使用代码安装node.js我们会用到一个工具就是我的homebrew（自带npm）安装命令如下：\nbrew install node\n检查node.js和npm是安装如果macOS上安装上了node.js和npm，macOS会告诉我版本号返回node.js版本号\nnode - v\n返回npm版本号\nnpm - v\n\nGit什么是GitGit是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper。\n代码安装Git使用代码安装Git我们会用到一个工具就是我的homebrew安装命令如下：\nbrew install git\n检查Git是安装如果macOS上安装上了Git，macOS会告诉我版本号返回Git版本号\ngit - v\n\n结语1、打开macOS终端2、输入代码下载 Git 和node.js3、检查是否下载成功","categories":["tool"],"tags":["node"]},{"title":"修改python的pip源","url":"/2022/01/18/8.pip/","content":"前言我这里是Windows10&#x2F;11专业工作版(其他Windows版本也适用)如果你的设备是已经是结束支持的Windows7，请查阅其他相关是手册什么是pippip 是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能。目前如果你在 python.org 下载最新版本的安装包，则是已经自带了该工具。注意：Python 2.7.9 + 或 Python 3.4+ 以上版本都自带 pip 工具。修改pip在使用Python安装包工具pip时经常会出现下载很慢的情况，这其中有很大一部分原因和pip的源有关.在我们安装python后，通常python解释器自带pip这个工具，但是这里pip是设置的默认源，也就是官方源：https://pypi.org/simple这个源在国内的下载速度是很慢的，所以我们为了提高包的下载速度我们可以通过换源来实现。\nPython pip国内源路径阿里云 http://mirrors.aliyun.com/pypi/simple/豆瓣(douban) http://pypi.douban.com/simple/清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/\n临时修改打开终端，在终端输入下面的换源代码换为清华源\npip install markdown -i https://pypi.tuna.tsinghua.edu.cn/simple\n换为阿里源\npip install markdown -i https://mirrors.aliyun.com/pypi/simple/\n换为腾讯源\npip install markdown -i http://mirrors.cloud.tencent.com/pypi/simple\n换为豆瓣源\npip install markdown -i http://pypi.douban.com/simple/\n永久修改打开终端，在终端输入下面的换源代码换为清华源\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n换为阿里源\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n换为腾讯源\npip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple\n换为豆瓣源\npip config set global.index-url http://pypi.douban.com/simple/\n修改为默认pip config unset global.index-url\n\n结语1、打开终端2、复制你要选择的pip源的修改代码3、粘贴到终端","categories":["tool"],"tags":["pip"]},{"title":"windows 11/10 的卓越性能模式？？","url":"/2022/01/18/8.%E7%8B%82%E6%9A%B4Windows/","content":"前言我这里是Windows10&#x2F;11专业工作版(其他Windows版本也适用)如果你的设备是已经是结束支持的Windows7，请查阅其他相关是手册\n\nWindows卓越性能模式：开启CPU鸡血状态的终极指南\n卓越性能模式是微软专为高性能需求设计的隐藏电源方案，它能让CPU持续保持”鸡血状态”，尤其适合游戏玩家和专业用户。但请注意：开启后会显著增加供电负担和散热需求，非工作站系统需手动开启。\n\n一、卓越性能模式核心解析1. 工作原理与特性\n\n\n特性\n平衡模式\n高性能模式\n卓越性能模式\n\n\n\nCPU基础频率\n动态调整\n保持较高\n始终维持最高\n\n\n睿频响应速度\n中等\n较快\n即时响应\n\n\n硬盘休眠策略\n激进\n保守\n永不休眠\n\n\n核心休眠状态\nC1-C6\nC1-C3\n仅C1\n\n\n适用场景\n日常办公\n游戏&#x2F;设计\n极致性能需求\n\n\n2. 适用系统版本\n✅ 原生支持：Windows 10&#x2F;11 企业版&#x2F;工作站版\n⚠️ 需手动开启：Windows 10&#x2F;11 专业版&#x2F;家庭版\n❌ 不支持：Windows 8.1及更早版本\n\n\n二、开启卓越性能模式完整教程方法1：通过PowerShell命令开启（推荐）# 以管理员身份运行Windows PowerShellwin+X → Windows PowerShell(管理员)# 执行启用命令powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61# 成功提示&quot;电源方案 GUID: 94f3c955-xxxx-xxxx-xxxx-xxxxxxxxxxxx (卓越性能)&quot;\n\n方法2：图形界面开启（适合初学者）\nWin+R打开运行 → 输入control打开控制面板\n进入”硬件和声音” → “电源选项”\n点击”显示附加计划”下拉箭头\n选择卓越性能模式\n\n\n\n三、高级优化设置指南1. CPU性能最大化设置Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Power\\PowerSettings\\54533251-82be-4824-96c1-47b60b740d00\\bc5038f7-23e0-4960-96da-33abaf5935ec]&quot;Attributes&quot;=dword:00000002\n应用后可在电源设置中调整：\n\n处理器性能提升模式 → 设置为”积极”\n最小处理器状态 → 设为100%\n\n2. PCI Express节能优化\n在卓越性能计划中点击”更改计划设置”\n进入”更改高级电源设置”\n展开PCI Express → 链接状态电源管理 → 设置为”关闭”\n\n3. USB选择性暂停设置电源选项 → USB设置 → USB选择性暂停设置 → 设置为&quot;已禁用&quot;\n\n四、性能监控与稳定性保障必备监控工具：\nHWiNFO64 - 实时监控CPU功耗&#x2F;温度\nMSI Afterburner - 游戏帧率与硬件状态监控\nThrottleStop - 防降频工具（特别笔记本用户）\n\n散热优化建议：\n台式机：确保CPU散热器TDP ≥ 实际功耗×1.2\n笔记本：使用散热支架+外置散热器\n定期清理散热器灰尘（每3个月至少1次）\n\n\n📌 关键指标警戒值：CPU温度≥90℃ | CPU功耗持续≥TDP的150% | 电压≥1.4V\n\n\n五、适用场景与注意事项👍 推荐开启场景：\nAAA级大型游戏（赛博朋克2077、艾尔登法环等）\n4K&#x2F;8K视频渲染\n科学计算&#x2F;深度学习\nVR内容创作\n\n⚠️ 重要注意事项：\n功耗增加：待机功耗增加15-30%，满载功耗增加8-15%\n硬件损耗：长期使用可能缩短硬件寿命\n散热需求：必须配备强力散热系统\n笔记本用户：插电时使用，电池模式下自动切换平衡模式\n日常使用：建议切回平衡模式延长硬件寿命\n\n\n六、模式切换与管理技巧快速切换脚本：# 创建卓越性能模式快捷脚本@echo offpowercfg /setactive e9a42b02-d5df-448d-aa00-03f14749eb61echo 卓越性能模式已激活！# 创建平衡模式恢复脚本@echo offpowercfg /setactive 381b4222-f694-41f0-9685-ff5bb260df2eecho 已切换回平衡模式\n\n自动化方案：\n使用Task Scheduler创建游戏启动触发任务\n关联卓越性能激活脚本\n游戏退出时自动恢复平衡模式\n\n\n终极建议：卓越性能模式是释放硬件潜力的双刃剑。游戏玩家可在战斗场景开启，创意工作者在渲染时启用，日常使用建议切回平衡模式。定期监控硬件温度，为你的爱机配备优质散热系统，才能在享受极致性能的同时保障硬件健康！\n","categories":["Windows"],"tags":["tool"]},{"title":"yarn的使用","url":"/2022/02/21/9.yarn/","content":"前言我这里是macOS Catalina（10.15），如果是macOS 11（big sur） 和 macOS 12（Monterey）也适用。老版本的macOS有些不被支持，请查阅相关文档什么是yarnYarn 是由 Facebook 于 2016 年发布的一款包管理工具，旨在取代 npm（Node Package Manager）。它的主要目的是解决 npm 的一些缺点，并提供更高级的包管理功能，以提高开发效率 。Yarn 的特点速度快：Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。同时利用并行下载以最大化资源利用率，因此安装速度更快。安全性高：在执行代码之前，Yarn 会通过算法校验每个安装包的完整性，确保包的安全性 。可靠性强：使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作 。安装 Yarn你可以通过 npm 来安装 Yarn：\nnpm install -g yarn\n安装完成后，可以通过以下命令查看 Yarn 的版本：\nyarn -v\n\n常用命令查看 Yarn 配置： yarn config list修改 Yarn 源 为淘宝源： yarn config set registry https://registry.npm.taobao.org安装依赖： yarn add 包名 # 局部安装 yarn global add 包名 # 全局安装卸载依赖： yarn remove 包名 # 局部卸载 yarn global remove 包名 # 全局卸载查看全局安装的包： yarn global listyarn 与 npm 的区别yarn 和 npm 都是用于管理项目依赖的工具，但它们在一些方面有所不同 ：安装速度：yarn 使用并行安装，而 npm 使用串行安装，因此 yarn 的安装速度更快。锁文件：yarn 使用 yarn.lock 文件来锁定依赖的版本，而 npm 使用 package-lock.json 文件。输出日志：yarn 的输出日志更简洁、易读，以树状格式呈现，而 npm 的输出日志较为杂乱。安全性：yarn 使用校验和来验证包的完整性，而 npm 使用 SHA-512 。总的来说，yarn 提供了更快、更安全、更可靠的包管理体验，是现代前端开发中常用的工具之一。yarn的常见问题1、安装问题2、网络问题3、依赖冲突或不一致结语yarn是macOS上的包管理组键，是用它和npm差不多，在使用的时候要注意如何解决问题\n\n","categories":["tool"],"tags":["yarn"]}]